<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Dockerfile | 刘新冬的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/img/logo.png">
    <meta name="description" content="Dockerfile, Dockerfile详解">
    
    <link rel="preload" href="/blog/assets/css/0.styles.ef7b091d.css" as="style"><link rel="preload" href="/blog/assets/js/app.6e13de4b.js" as="script"><link rel="preload" href="/blog/assets/js/2.ba6b1436.js" as="script"><link rel="preload" href="/blog/assets/js/1.2d4ce02f.js" as="script"><link rel="preload" href="/blog/assets/js/37.3ff8f40c.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.14082ad8.js"><link rel="prefetch" href="/blog/assets/js/100.3fe3bc9e.js"><link rel="prefetch" href="/blog/assets/js/101.b0c6af63.js"><link rel="prefetch" href="/blog/assets/js/102.f5b300a6.js"><link rel="prefetch" href="/blog/assets/js/103.1acb1fc5.js"><link rel="prefetch" href="/blog/assets/js/104.bead4590.js"><link rel="prefetch" href="/blog/assets/js/105.b3e3eda0.js"><link rel="prefetch" href="/blog/assets/js/106.34b60003.js"><link rel="prefetch" href="/blog/assets/js/107.7fb680b6.js"><link rel="prefetch" href="/blog/assets/js/108.374085fd.js"><link rel="prefetch" href="/blog/assets/js/109.e8cb0cd1.js"><link rel="prefetch" href="/blog/assets/js/11.d36ef131.js"><link rel="prefetch" href="/blog/assets/js/12.c5493e01.js"><link rel="prefetch" href="/blog/assets/js/13.430eca0c.js"><link rel="prefetch" href="/blog/assets/js/14.c88f86cd.js"><link rel="prefetch" href="/blog/assets/js/15.e1cc950a.js"><link rel="prefetch" href="/blog/assets/js/16.b699b95c.js"><link rel="prefetch" href="/blog/assets/js/17.b99ba729.js"><link rel="prefetch" href="/blog/assets/js/18.7dff4b06.js"><link rel="prefetch" href="/blog/assets/js/19.ff06d982.js"><link rel="prefetch" href="/blog/assets/js/20.7de9995c.js"><link rel="prefetch" href="/blog/assets/js/21.cb9bdcf0.js"><link rel="prefetch" href="/blog/assets/js/22.16dfd536.js"><link rel="prefetch" href="/blog/assets/js/23.bf77e72b.js"><link rel="prefetch" href="/blog/assets/js/24.e5007a9f.js"><link rel="prefetch" href="/blog/assets/js/25.c7f21645.js"><link rel="prefetch" href="/blog/assets/js/26.64d829b6.js"><link rel="prefetch" href="/blog/assets/js/27.cb93dd1f.js"><link rel="prefetch" href="/blog/assets/js/28.f119234c.js"><link rel="prefetch" href="/blog/assets/js/29.4ebed3b0.js"><link rel="prefetch" href="/blog/assets/js/3.00356991.js"><link rel="prefetch" href="/blog/assets/js/30.64faf300.js"><link rel="prefetch" href="/blog/assets/js/31.34e09941.js"><link rel="prefetch" href="/blog/assets/js/32.d97feb3b.js"><link rel="prefetch" href="/blog/assets/js/33.989013a1.js"><link rel="prefetch" href="/blog/assets/js/34.e4da7325.js"><link rel="prefetch" href="/blog/assets/js/35.31a69502.js"><link rel="prefetch" href="/blog/assets/js/36.f7df77c6.js"><link rel="prefetch" href="/blog/assets/js/38.07773b13.js"><link rel="prefetch" href="/blog/assets/js/39.6bc6e475.js"><link rel="prefetch" href="/blog/assets/js/4.7fa5c39e.js"><link rel="prefetch" href="/blog/assets/js/40.d4372ff1.js"><link rel="prefetch" href="/blog/assets/js/41.fc9f747a.js"><link rel="prefetch" href="/blog/assets/js/42.1b630c60.js"><link rel="prefetch" href="/blog/assets/js/43.53183817.js"><link rel="prefetch" href="/blog/assets/js/44.8a25fb48.js"><link rel="prefetch" href="/blog/assets/js/45.05d8c3dc.js"><link rel="prefetch" href="/blog/assets/js/46.0dc47250.js"><link rel="prefetch" href="/blog/assets/js/47.a769691a.js"><link rel="prefetch" href="/blog/assets/js/48.0e49b5c3.js"><link rel="prefetch" href="/blog/assets/js/49.2c4b0b01.js"><link rel="prefetch" href="/blog/assets/js/5.8a935be6.js"><link rel="prefetch" href="/blog/assets/js/50.d48b16f0.js"><link rel="prefetch" href="/blog/assets/js/51.7dceb146.js"><link rel="prefetch" href="/blog/assets/js/52.b6ae0713.js"><link rel="prefetch" href="/blog/assets/js/53.046b88a2.js"><link rel="prefetch" href="/blog/assets/js/54.b5596254.js"><link rel="prefetch" href="/blog/assets/js/55.f9077d07.js"><link rel="prefetch" href="/blog/assets/js/56.7cd32adc.js"><link rel="prefetch" href="/blog/assets/js/57.07a79e6c.js"><link rel="prefetch" href="/blog/assets/js/58.3c2714d1.js"><link rel="prefetch" href="/blog/assets/js/59.2942e8a9.js"><link rel="prefetch" href="/blog/assets/js/6.c6745fa4.js"><link rel="prefetch" href="/blog/assets/js/60.2034c67b.js"><link rel="prefetch" href="/blog/assets/js/61.af320179.js"><link rel="prefetch" href="/blog/assets/js/62.a7b30842.js"><link rel="prefetch" href="/blog/assets/js/63.242b7861.js"><link rel="prefetch" href="/blog/assets/js/64.08909954.js"><link rel="prefetch" href="/blog/assets/js/65.c5c5f29e.js"><link rel="prefetch" href="/blog/assets/js/66.1f2fccf4.js"><link rel="prefetch" href="/blog/assets/js/67.6fe3be02.js"><link rel="prefetch" href="/blog/assets/js/68.6b40d6ba.js"><link rel="prefetch" href="/blog/assets/js/69.c6a9d2c9.js"><link rel="prefetch" href="/blog/assets/js/7.f127ebf8.js"><link rel="prefetch" href="/blog/assets/js/70.00b93126.js"><link rel="prefetch" href="/blog/assets/js/71.133e5d42.js"><link rel="prefetch" href="/blog/assets/js/72.cf6be888.js"><link rel="prefetch" href="/blog/assets/js/73.2cdd2145.js"><link rel="prefetch" href="/blog/assets/js/74.f55dcc81.js"><link rel="prefetch" href="/blog/assets/js/75.c48d7781.js"><link rel="prefetch" href="/blog/assets/js/76.d6244710.js"><link rel="prefetch" href="/blog/assets/js/77.6f4860be.js"><link rel="prefetch" href="/blog/assets/js/78.e9ebefa1.js"><link rel="prefetch" href="/blog/assets/js/79.693e869a.js"><link rel="prefetch" href="/blog/assets/js/80.1e0ccca6.js"><link rel="prefetch" href="/blog/assets/js/81.62dd7db1.js"><link rel="prefetch" href="/blog/assets/js/82.ef0d1455.js"><link rel="prefetch" href="/blog/assets/js/83.445b9c32.js"><link rel="prefetch" href="/blog/assets/js/84.2c72ae76.js"><link rel="prefetch" href="/blog/assets/js/85.dc69de5f.js"><link rel="prefetch" href="/blog/assets/js/86.5487c200.js"><link rel="prefetch" href="/blog/assets/js/87.27164930.js"><link rel="prefetch" href="/blog/assets/js/88.1f0b6531.js"><link rel="prefetch" href="/blog/assets/js/89.c4633f89.js"><link rel="prefetch" href="/blog/assets/js/90.ab0308ed.js"><link rel="prefetch" href="/blog/assets/js/91.e9b62cd3.js"><link rel="prefetch" href="/blog/assets/js/92.c604ad6a.js"><link rel="prefetch" href="/blog/assets/js/93.b9aed2ed.js"><link rel="prefetch" href="/blog/assets/js/94.316923a2.js"><link rel="prefetch" href="/blog/assets/js/95.85b9ac03.js"><link rel="prefetch" href="/blog/assets/js/96.868fa86d.js"><link rel="prefetch" href="/blog/assets/js/97.e9923d97.js"><link rel="prefetch" href="/blog/assets/js/98.b947130d.js"><link rel="prefetch" href="/blog/assets/js/99.73579e22.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.162bdabc.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.ef7b091d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="刘新冬的博客" class="logo"> <span class="site-name can-hide">刘新冬的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Docker</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/docker/" aria-current="page" class="sidebar-link">简介</a></li><li><a href="/blog/docker/default/基本概念.html" class="sidebar-link">基本概念</a></li><li><a href="/blog/docker/default/常用操作.html" class="sidebar-link">常用操作</a></li><li><a href="/blog/docker/default/docker_run.html" class="sidebar-link">docker run 详解</a></li><li><a href="/blog/docker/default/Dockerfile.html" aria-current="page" class="active sidebar-link">Dockerfile</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#from" class="sidebar-link">FROM</a></li><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#arg" class="sidebar-link">ARG</a></li><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#env" class="sidebar-link">ENV</a></li><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#workdir" class="sidebar-link">WORKDIR</a></li><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#copy" class="sidebar-link">COPY</a></li><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#add" class="sidebar-link">ADD</a></li><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#expose" class="sidebar-link">EXPOSE</a></li><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#run" class="sidebar-link">RUN</a></li><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#cmd" class="sidebar-link">CMD</a></li><li class="sidebar-sub-header"><a href="/blog/docker/default/Dockerfile.html#entrypoint" class="sidebar-link">ENTRYPOINT</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><code>Dockerfile</code> 是一个文本文件，它包含了所有用来组建镜像的可执行的命令。通过 <code>docker build</code> 指令可以从 <code>Dockerfile</code> 来构建镜像。</p> <p><code>Dockerfile</code> 由一系列指令构成，来定义构建镜像的步骤，文件书写格式为：</p> <div class="language- extra-class"><pre class="language-text"><code>指令 参数
</code></pre></div><p>指令不对大小写敏感，但是还是建议使用大写格式。</p> <p>docker按顺序执行 <code>Dockerfile</code> 中的指令。<code>Dockerfile</code> 必须以 <code>FROM</code> 指令开始。 <code>FROM</code> 指令前可以有一个或者多个 <code>ARG</code> 指令，这些 <code>ARG</code> 指令声明了在 <code>FROM</code> 指令中用到的参数。</p> <p><code>Dockerfile</code> 中，以 <code>#</code> 开头的行被视作注释，在加载时，注释行将被忽略。</p> <p><code>Dockerfile</code> 支持如下指令：</p> <h2 id="from"><a href="#from" class="header-anchor">#</a> FROM</h2> <p>指定基础镜像（即当前镜像是基于哪个镜像构建）。</p> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]
</code></pre></div><p>或者</p> <div class="language- extra-class"><pre class="language-text"><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]
</code></pre></div><p>或者</p> <div class="language- extra-class"><pre class="language-text"><code>FROM [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]
</code></pre></div><br> <p><strong>注意：</strong></p> <ul><li>只有 <code>ARG</code> 指令能够声明在 <code>FROM</code> 指令前面。</li> <li>可以存在多个 <code>FROM</code> 指令，用来创建多个镜像或者作为不同的构建阶段。每个 <code>FROM</code> 指令执行，都会清除上一个 <code>FROM</code> 指令创建的所有状态。</li> <li>可以在 <code>FROM</code> 指令后添加 <code>AS name</code> 来赋予构建出的镜像一个名称，在当前 Dockerfile 的后续 <code>FROM</code> 指令和 <code>COPY --from=&lt;name&gt;</code> 指令可以通过该名称引用到其表示的镜像。</li> <li><code>tag</code> 或 <code>digest</code> 的值是可选的，如果未指定，那么将使用 <code>latest</code> 作为默认值。</li></ul> <br> <p><strong>示例：</strong></p> <p>在下面的示例中，<code>FROM</code> 指令和 <code>RUN</code> 指令都要引用参数 VERSION，但只有 <code>FROM</code> 指令能够成功，RUN 指令会失败，这是 <code>FROM</code> 执行后会清除其之前的状态：</p> <div class="language- extra-class"><pre class="language-text"><code>ARG VERSION=latest
FROM busybox:$VERSION
RUN echo $VERSION &gt; image_version
</code></pre></div><p>如果想要在多个指令中引用 FROM 指令之前声明的变量，那么可以通过再次声明不带有默认值的变量的形式：</p> <div class="language- extra-class"><pre class="language-text"><code>ARG VERSION=latest
FROM busybox:$VERSION
ARG VERSION
RUN echo $VERSION &gt; image_version
</code></pre></div><h2 id="arg"><a href="#arg" class="header-anchor">#</a> ARG</h2> <p>声明参数，<strong>通过 <code>ARG</code> 声明的参数仅作用于镜像的构建阶段，在容器运行阶段是无法获取到其声明的参数的</strong>。</p> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>ARG name[=value]
</code></pre></div><br> <p><strong>示例：</strong></p> <ul><li><p>声明一个未赋值的参数</p> <div class="language- extra-class"><pre class="language-text"><code>ARG user
</code></pre></div></li> <li><p>声明一个参数并赋值</p> <div class="language- extra-class"><pre class="language-text"><code>ARG user=liuxindong
</code></pre></div></li> <li><p>使用参数</p> <div class="language- extra-class"><pre class="language-text"><code>ARG parent_image=jdk1.8
FROM $parent_image
</code></pre></div></li></ul> <h2 id="env"><a href="#env" class="header-anchor">#</a> ENV</h2> <p>设置环境变量，<strong>通过 <code>ENV</code> 声明的变量不仅作用于镜像的构建阶段，在容器运行阶段是也可以获取到</strong>。</p> <p><strong>建议：</strong> 如果只是在构建阶段使用的变量，那么用 <code>ARG</code> 来声明，否则用 <code>ENV</code> 来声明。</p> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>ENV &lt;key&gt;=&lt;value&gt; ...
</code></pre></div><br> <p>如果某些特殊字符不经过转义，那么变量的声明将被打断。可以通过反斜杠或者双引号在变量值中使用空白字符。如：</p> <div class="language- extra-class"><pre class="language-text"><code>ENV MY_NAME=&quot;John Doe&quot;
ENV MY_DOG=Rex\ The\ Dog
ENV MY_CAT=fluffy
</code></pre></div><p>可在一个<code>ENV</code>指令中声明多个变量：</p> <div class="language- extra-class"><pre class="language-text"><code>ENV MY_NAME=&quot;John Doe&quot; MY_DOG=Rex\ The\ Dog \
    MY_CAT=fluffy
</code></pre></div><p>通过 <code>ENV</code> 声明的变量会持久化到该镜像的容器中，可以通过 <code>docker inspect</code> 来查看，并且可通过 <code>docker run --env &lt;key&gt;=&lt;value&gt;</code> 来修改。</p> <h2 id="workdir"><a href="#workdir" class="header-anchor">#</a> WORKDIR</h2> <p>为 <code>RUN</code>, <code>CMD</code>, <code>ENTRYPOINT</code>, <code>COPY</code> 和 <code>ADD</code> 这些指令设置工作目录。</p> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>WORKDIR /path/to/workdir
</code></pre></div><br> <p><strong>示例：</strong></p> <p><code>WORKDIR</code> 指令可声明多次，如果声明时使用的是相对路径，那么将表示相对于上一个 <code>WORKDIR</code> 声明的路径，比如下面的示例：</p> <div class="language- extra-class"><pre class="language-text"><code>WORKDIR /a
WORKDIR b
WORKDIR c
RUN pwd
</code></pre></div><p><code>pwd</code>命令运行后的输出文件所在目录为  <code>/a/b/c</code> 。</p> <p><code>WORKDIR</code> 指令可以解析 <code>ENV</code> 声明的变量，如：</p> <div class="language- extra-class"><pre class="language-text"><code>ENV DIRPATH=/path
WORKDIR $DIRPATH/$DIRNAME
RUN pwd
</code></pre></div><p><code>pwd</code>命令运行后的输出文件所在目录为  <code>/path/$DIRNAME</code> 。</p> <h2 id="copy"><a href="#copy" class="header-anchor">#</a> COPY</h2> <p>拷贝宿主机中文件、文件夹到容器中。</p> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
</code></pre></div><p>或</p> <div class="language- extra-class"><pre class="language-text"><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]
</code></pre></div><br> <p><strong>示例：</strong></p> <ul><li><p>拷贝宿主机中/home/aaa.tar文件到容器中的/home目录下</p> <div class="language- extra-class"><pre class="language-text"><code>COPY /home/aaa.tar /home
</code></pre></div></li> <li><p>拷贝宿主机中多个文件到容器/home目录下</p> <div class="language- extra-class"><pre class="language-text"><code>COPY /home/aaa.tar /home/bbb.tar /home/  # 拷贝多个文件时，容器目录必须以/结尾
</code></pre></div></li> <li><p>拷贝宿主机文件到容器当前路径（<code>WORKDIR</code> 声明的路径）的deploy目录下</p> <div class="language- extra-class"><pre class="language-text"><code>COPY /home/aaa.tar ./deploy
</code></pre></div></li> <li><p>宿主机文件支持通配符，其使用的是Go语言的 <a href="http://golang.org/pkg/path/filepath#Match" target="_blank" rel="noopener noreferrer">filepath.Match<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 规则</p> <div class="language- extra-class"><pre class="language-text"><code>COPY hom* /mydir/		# 拷贝所有以 hom 开头的文件
COPY hom?.txt /mydir/ 	# 拷贝所有以 hom 开头的txt文件
</code></pre></div></li></ul> <h2 id="add"><a href="#add" class="header-anchor">#</a> ADD</h2> <p>拷贝宿主机中文件、文件夹或者远程文件到容器中。如果拷贝的是tar文件，那么拷贝到容器中后会自动解压。</p> <p><strong><code>ADD</code>与 <code>COPY</code> 的区别：</strong></p> <ul><li>支持远程文件</li> <li>如果是tar文件，拷贝完成后自动解压</li></ul> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;
</code></pre></div><p>或</p> <div class="language- extra-class"><pre class="language-text"><code>ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]
</code></pre></div><br> <p>示例可参考 <code>COPY</code> 指令</p> <h2 id="expose"><a href="#expose" class="header-anchor">#</a> EXPOSE</h2> <p>声明容器可对外开放的端口。</p> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]
</code></pre></div><br> <p><strong>示例：</strong></p> <p>可以对端口协议进行标识，来区分是 UDP 还是 TCP，当不进行特殊标识时，默认为 TCP。如：</p> <div class="language- extra-class"><pre class="language-text"><code>EXPOSE 8080				  # 监听8080端口，tcp协议
EXPOSE 8081/tcp			# 监听8081端口，tcp协议
EXPOSE 8082/udp			# 监听8082端口，udp协议
EXPOSE 8083/tcp			# 监听8083端口，tcp协议
EXPOSE 8083/udp			# 监听8083端口，udp协议
</code></pre></div><br> <p><strong>注意：</strong></p> <p><code>EXPOSE</code> 仅仅是声明容器可对外开发的端口，但是并没有直接对外开放，容器启动后，如果需要允许外部访问，仍需要在 <code>docker run</code> 或者 <code>docker create</code> 时，通过 <code>-p</code> 参数来进行端口映射实现对外开放</p> <div class="language- extra-class"><pre class="language-text"><code>docker run -p 8080:8080 -p 8081:8081/tcp -p 8082:8082/udp ...
</code></pre></div><h2 id="run"><a href="#run" class="header-anchor">#</a> RUN</h2> <p>声明在<strong>构建阶段</strong>要执行的命令，这些命令执行完成后的结果可在后续的构建过程中使用。</p> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>RUN &lt;command&gt;    # shell格式
</code></pre></div><p>或</p> <div class="language- extra-class"><pre class="language-text"><code>RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]     # exec格式
</code></pre></div><br> <p><strong>示例：</strong></p> <ul><li><p>shell格式</p> <div class="language- extra-class"><pre class="language-text"><code>RUN mkdir -p /home/aaa
</code></pre></div></li> <li><p>exec格式</p> <div class="language- extra-class"><pre class="language-text"><code>RUN [&quot;mkdir&quot;, &quot;-p&quot;, &quot;/home/aaa&quot;]
</code></pre></div></li></ul> <br> <p><strong>注意：</strong></p> <ul><li><p>使用exec格式时，要处理好字符的转义问题，如：</p> <div class="language- extra-class"><pre class="language-text"><code>RUN [&quot;c:\windows\system32\tasklist.exe&quot;]
</code></pre></div><p>上述声明存在字符未转义问题，正确写法为：</p> <div class="language- extra-class"><pre class="language-text"><code>RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]
</code></pre></div></li> <li><p>使用shell格式时，可通过 <code>\</code> 来实现换行，如：</p> <div class="language- extra-class"><pre class="language-text"><code>RUN /bin/bash -c 'source $HOME/.bashrc; \
echo $HOME'
</code></pre></div><p>等价于</p> <div class="language- extra-class"><pre class="language-text"><code>RUN /bin/bash -c 'source $HOME/.bashrc; echo $HOME'
</code></pre></div></li></ul> <h2 id="cmd"><a href="#cmd" class="header-anchor">#</a> CMD</h2> <p>定义容器启动后要执行的命令。可以声明多个 <code>CMD</code> 指令，但是只有最后一个生效。</p> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]     # exec格式（官方推荐）
</code></pre></div><p>或者</p> <div class="language- extra-class"><pre class="language-text"><code>CMD command param1 param2    # shell格式
</code></pre></div><br> <p><strong>示例：</strong></p> <ul><li><p>shell格式</p> <div class="language- extra-class"><pre class="language-text"><code>CMD mkdir -p /home/aaa
</code></pre></div></li> <li><p>exec格式</p> <div class="language- extra-class"><pre class="language-text"><code>CMD [&quot;mkdir&quot;, &quot;-p&quot;, &quot;/home/aaa&quot;]
</code></pre></div></li></ul> <br> <p><code>CMD</code> 定义的命令可以被 <code>docker run</code> 命令的参数覆盖。</p> <p>例如我们在Dockerfile文件中定义：</p> <div class="language- extra-class"><pre class="language-text"><code>CMD [&quot;/bin/echo&quot;, &quot;i am jack&quot;] 
</code></pre></div><p>构建镜像并运行容器：</p> <div class="language- extra-class"><pre class="language-text"><code>docker build -t myimage &amp;&amp; docker run myimage
</code></pre></div><p>控制台输出内容为：</p> <div class="language- extra-class"><pre class="language-text"><code>i am jack
</code></pre></div><p>如果我们 <code>docker run</code> 命令中指定参数，如下：</p> <div class="language- extra-class"><pre class="language-text"><code>docker runmyimage /bin/bash
</code></pre></div><p>那么命令行将不再有输出，也就是 <code>CMD</code> 定义的命令被覆盖了。</p> <br> <p><strong>注意：</strong></p> <ul><li><p>使用exec格式时，要处理好字符的转义问题，如：</p> <div class="language- extra-class"><pre class="language-text"><code>CMD [&quot;c:\windows\system32\tasklist.exe&quot;]
</code></pre></div><p>上述声明存在字符未转义问题，正确写法为：</p> <div class="language- extra-class"><pre class="language-text"><code>CMD [&quot;c:\\windows\\system32\\tasklist.exe&quot;]
</code></pre></div></li> <li><p>使用shell格式时，可通过 <code>\</code> 来实现换行，如：</p> <div class="language- extra-class"><pre class="language-text"><code>CMD /bin/bash -c 'source $HOME/.bashrc; \
echo $HOME'
</code></pre></div><p>等价于</p> <div class="language- extra-class"><pre class="language-text"><code>CMD /bin/bash -c 'source $HOME/.bashrc; echo $HOME'
</code></pre></div></li></ul> <h2 id="entrypoint"><a href="#entrypoint" class="header-anchor">#</a> ENTRYPOINT</h2> <p>定义容器启动后要执行的命令。可以声明多个 <code>ENTRYPOINT</code> 指令，但是只有最后一个生效。</p> <br> <p><strong>格式：</strong></p> <div class="language- extra-class"><pre class="language-text"><code>ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]     # exec格式（官方推荐）
</code></pre></div><p>或者</p> <div class="language- extra-class"><pre class="language-text"><code>ENTRYPOINT command param1 param2    # shell格式
</code></pre></div><br> <p><strong>示例：</strong></p> <ul><li><p>shell格式</p> <div class="language- extra-class"><pre class="language-text"><code>ENTRYPOINT mkdir -p /home/aaa
</code></pre></div></li> <li><p>exec格式</p> <div class="language- extra-class"><pre class="language-text"><code>ENTRYPOINT [&quot;mkdir&quot;, &quot;-p&quot;, &quot;/home/aaa&quot;]
</code></pre></div></li></ul> <br> <p>当使用exec格式时， 可以通过 <code>docker run</code> 命令的 <code>--entrypoint</code> 参数来覆盖  <code>ENTRYPOINT</code> 指令定义的命令，如：</p> <div class="language- extra-class"><pre class="language-text"><code>docker run myimage --entrypoint /bin/bash
</code></pre></div><p>此时， <code>ENTRYPOINT</code> 指令定义的命令将会被覆盖成 /bin/bash</p> <br> <p><strong><code>ENTRYPOINT</code> 与 <code>CMD</code> 的区别：</strong></p> <p><code>ENTRYPOINT</code> 可以使容器表现得更像是一个可执行程序，例如在Dockerfile文件中定义：</p> <div class="language- extra-class"><pre class="language-text"><code>ENTRYPOINT [&quot;/bin/echo&quot;]
</code></pre></div><p>构建后执行：</p> <div class="language- extra-class"><pre class="language-text"><code>docker run myimage &quot;this is a test&quot;
</code></pre></div><p>控制台将输出：</p> <div class="language- extra-class"><pre class="language-text"><code>this is a test
</code></pre></div><p>看，这个容器就像是一个echo程序一样。</p> <br> <p>通常， <code>ENTRYPOINT</code> 和  <code>CMD</code> 搭配使用， <code>ENTRYPOINT</code> 来定义固定不变的命令，而 <code>CMD</code> 来定义可以变化的命令。</p> <p>例如我们在编写构建一个nodejs服务镜像的Dockerfile文件，有如下定义：</p> <div class="language- extra-class"><pre class="language-text"><code>ENTRYPOINT [&quot;node&quot;]
CMD [&quot;/home/app1/index.js&quot;]
</code></pre></div><p>构建并运行：</p> <div class="language- extra-class"><pre class="language-text"><code>docker build -t myimage &amp;&amp; docker run myimage
</code></pre></div><p>那么容器将会启动nodejs服务，并加载 <code>/home/app1/index.js</code> 文件。</p> <p>如果我们想要在容器启动时，加载 <code>/home/app2</code> 下的 <code>index.js</code> 文件，我们可以执行如下命令：</p> <div class="language- extra-class"><pre class="language-text"><code>docker run myimage /home/app2/index.js
</code></pre></div><p>此时，容器启动后将加载 <code>/home/app2/index.js</code> 文件。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/docker/default/docker_run.html" class="prev">
        docker run 详解
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.6e13de4b.js" defer></script><script src="/blog/assets/js/2.ba6b1436.js" defer></script><script src="/blog/assets/js/1.2d4ce02f.js" defer></script><script src="/blog/assets/js/37.3ff8f40c.js" defer></script>
  </body>
</html>
