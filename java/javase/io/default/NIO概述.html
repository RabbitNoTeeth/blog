<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>NIO概述 | 刘新冬的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/img/logo.png">
    <meta name="description" content="NIO概述">
    
    <link rel="preload" href="/blog/assets/css/0.styles.ef7b091d.css" as="style"><link rel="preload" href="/blog/assets/js/app.8d6c0f8a.js" as="script"><link rel="preload" href="/blog/assets/js/2.ba6b1436.js" as="script"><link rel="preload" href="/blog/assets/js/1.2d4ce02f.js" as="script"><link rel="preload" href="/blog/assets/js/95.9fc69c4a.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.14082ad8.js"><link rel="prefetch" href="/blog/assets/js/100.2a4f0938.js"><link rel="prefetch" href="/blog/assets/js/101.8a62150f.js"><link rel="prefetch" href="/blog/assets/js/102.35a7e2ea.js"><link rel="prefetch" href="/blog/assets/js/103.faae61d0.js"><link rel="prefetch" href="/blog/assets/js/104.c27f3d0b.js"><link rel="prefetch" href="/blog/assets/js/105.9326a988.js"><link rel="prefetch" href="/blog/assets/js/106.0c2ccacd.js"><link rel="prefetch" href="/blog/assets/js/107.97cdca5d.js"><link rel="prefetch" href="/blog/assets/js/108.c36e9500.js"><link rel="prefetch" href="/blog/assets/js/11.d36ef131.js"><link rel="prefetch" href="/blog/assets/js/12.c5493e01.js"><link rel="prefetch" href="/blog/assets/js/13.430eca0c.js"><link rel="prefetch" href="/blog/assets/js/14.c88f86cd.js"><link rel="prefetch" href="/blog/assets/js/15.e1cc950a.js"><link rel="prefetch" href="/blog/assets/js/16.b699b95c.js"><link rel="prefetch" href="/blog/assets/js/17.b99ba729.js"><link rel="prefetch" href="/blog/assets/js/18.7dff4b06.js"><link rel="prefetch" href="/blog/assets/js/19.ff06d982.js"><link rel="prefetch" href="/blog/assets/js/20.7de9995c.js"><link rel="prefetch" href="/blog/assets/js/21.cb9bdcf0.js"><link rel="prefetch" href="/blog/assets/js/22.16dfd536.js"><link rel="prefetch" href="/blog/assets/js/23.eb560dbc.js"><link rel="prefetch" href="/blog/assets/js/24.661e2539.js"><link rel="prefetch" href="/blog/assets/js/25.c7f21645.js"><link rel="prefetch" href="/blog/assets/js/26.64d829b6.js"><link rel="prefetch" href="/blog/assets/js/27.cb93dd1f.js"><link rel="prefetch" href="/blog/assets/js/28.f119234c.js"><link rel="prefetch" href="/blog/assets/js/29.4ebed3b0.js"><link rel="prefetch" href="/blog/assets/js/3.00356991.js"><link rel="prefetch" href="/blog/assets/js/30.b200e052.js"><link rel="prefetch" href="/blog/assets/js/31.fe5fff12.js"><link rel="prefetch" href="/blog/assets/js/32.85a049c3.js"><link rel="prefetch" href="/blog/assets/js/33.9461dbb1.js"><link rel="prefetch" href="/blog/assets/js/34.f41e8fd5.js"><link rel="prefetch" href="/blog/assets/js/35.58834759.js"><link rel="prefetch" href="/blog/assets/js/36.06d083bd.js"><link rel="prefetch" href="/blog/assets/js/37.eee1a984.js"><link rel="prefetch" href="/blog/assets/js/38.947f70d3.js"><link rel="prefetch" href="/blog/assets/js/39.6902573c.js"><link rel="prefetch" href="/blog/assets/js/4.7fa5c39e.js"><link rel="prefetch" href="/blog/assets/js/40.272641e4.js"><link rel="prefetch" href="/blog/assets/js/41.1e890684.js"><link rel="prefetch" href="/blog/assets/js/42.351f521c.js"><link rel="prefetch" href="/blog/assets/js/43.5f3ad053.js"><link rel="prefetch" href="/blog/assets/js/44.d88da63e.js"><link rel="prefetch" href="/blog/assets/js/45.f86d4d09.js"><link rel="prefetch" href="/blog/assets/js/46.a073f698.js"><link rel="prefetch" href="/blog/assets/js/47.50e3be7d.js"><link rel="prefetch" href="/blog/assets/js/48.cb688c31.js"><link rel="prefetch" href="/blog/assets/js/49.e239b0d8.js"><link rel="prefetch" href="/blog/assets/js/5.8a935be6.js"><link rel="prefetch" href="/blog/assets/js/50.fa5eb795.js"><link rel="prefetch" href="/blog/assets/js/51.3851b429.js"><link rel="prefetch" href="/blog/assets/js/52.505afb46.js"><link rel="prefetch" href="/blog/assets/js/53.6c2661e4.js"><link rel="prefetch" href="/blog/assets/js/54.e1f8a27e.js"><link rel="prefetch" href="/blog/assets/js/55.4fac431c.js"><link rel="prefetch" href="/blog/assets/js/56.afbe8c4d.js"><link rel="prefetch" href="/blog/assets/js/57.018b5640.js"><link rel="prefetch" href="/blog/assets/js/58.14d0549e.js"><link rel="prefetch" href="/blog/assets/js/59.7e810fa1.js"><link rel="prefetch" href="/blog/assets/js/6.c6745fa4.js"><link rel="prefetch" href="/blog/assets/js/60.ea3fa83f.js"><link rel="prefetch" href="/blog/assets/js/61.e707010c.js"><link rel="prefetch" href="/blog/assets/js/62.2d1d40f2.js"><link rel="prefetch" href="/blog/assets/js/63.e3169d4d.js"><link rel="prefetch" href="/blog/assets/js/64.492fcc89.js"><link rel="prefetch" href="/blog/assets/js/65.2ebe492f.js"><link rel="prefetch" href="/blog/assets/js/66.b9c8f37b.js"><link rel="prefetch" href="/blog/assets/js/67.1d25c263.js"><link rel="prefetch" href="/blog/assets/js/68.161a6387.js"><link rel="prefetch" href="/blog/assets/js/69.2816cb57.js"><link rel="prefetch" href="/blog/assets/js/7.f127ebf8.js"><link rel="prefetch" href="/blog/assets/js/70.c8ef9312.js"><link rel="prefetch" href="/blog/assets/js/71.0be7a2dd.js"><link rel="prefetch" href="/blog/assets/js/72.854348ee.js"><link rel="prefetch" href="/blog/assets/js/73.d2853fce.js"><link rel="prefetch" href="/blog/assets/js/74.62382ee2.js"><link rel="prefetch" href="/blog/assets/js/75.b640bef7.js"><link rel="prefetch" href="/blog/assets/js/76.25e395ba.js"><link rel="prefetch" href="/blog/assets/js/77.38238ae4.js"><link rel="prefetch" href="/blog/assets/js/78.9ab2dade.js"><link rel="prefetch" href="/blog/assets/js/79.821ae10e.js"><link rel="prefetch" href="/blog/assets/js/80.bffcdf54.js"><link rel="prefetch" href="/blog/assets/js/81.77850ad7.js"><link rel="prefetch" href="/blog/assets/js/82.54640e5e.js"><link rel="prefetch" href="/blog/assets/js/83.9367f8bf.js"><link rel="prefetch" href="/blog/assets/js/84.a16891a8.js"><link rel="prefetch" href="/blog/assets/js/85.19e32374.js"><link rel="prefetch" href="/blog/assets/js/86.2eadc3ff.js"><link rel="prefetch" href="/blog/assets/js/87.aa8809c5.js"><link rel="prefetch" href="/blog/assets/js/88.3181413a.js"><link rel="prefetch" href="/blog/assets/js/89.721fc390.js"><link rel="prefetch" href="/blog/assets/js/90.e4ce6df4.js"><link rel="prefetch" href="/blog/assets/js/91.c14bd802.js"><link rel="prefetch" href="/blog/assets/js/92.bac05565.js"><link rel="prefetch" href="/blog/assets/js/93.98011bc4.js"><link rel="prefetch" href="/blog/assets/js/94.614bbf82.js"><link rel="prefetch" href="/blog/assets/js/96.09e8cb5f.js"><link rel="prefetch" href="/blog/assets/js/97.5725166b.js"><link rel="prefetch" href="/blog/assets/js/98.171f107c.js"><link rel="prefetch" href="/blog/assets/js/99.6806f377.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.162bdabc.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.ef7b091d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="刘新冬的博客" class="logo"> <span class="site-name can-hide">刘新冬的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaSE</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/" aria-current="page" class="sidebar-link">简介</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>集合</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/collection/default/Collection.html" class="sidebar-link">Collection</a></li><li><a href="/blog/java/javase/collection/default/List.html" class="sidebar-link">List</a></li><li><a href="/blog/java/javase/collection/default/Map.html" class="sidebar-link">Map</a></li><li><a href="/blog/java/javase/collection/default/Queue.html" class="sidebar-link">Queue</a></li><li><a href="/blog/java/javase/collection/default/Set.html" class="sidebar-link">Set</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/concurrent/default/设计线程安全的类.html" class="sidebar-link">设计线程安全的类</a></li><li><a href="/blog/java/javase/concurrent/default/基础构建模块.html" class="sidebar-link">基础构建模块</a></li><li><a href="/blog/java/javase/concurrent/default/任务执行.html" class="sidebar-link">任务执行</a></li><li><a href="/blog/java/javase/concurrent/default/取消与关闭.html" class="sidebar-link">取消与关闭</a></li><li><a href="/blog/java/javase/concurrent/default/线程池的使用.html" class="sidebar-link">线程池的使用</a></li><li><a href="/blog/java/javase/concurrent/default/死锁.html" class="sidebar-link">死锁</a></li><li><a href="/blog/java/javase/concurrent/default/性能与可伸缩性.html" class="sidebar-link">性能与可伸缩性</a></li><li><a href="/blog/java/javase/concurrent/default/显式锁.html" class="sidebar-link">显式锁</a></li><li><a href="/blog/java/javase/concurrent/default/构建自定义的同步工具.html" class="sidebar-link">构建自定义的同步工具</a></li><li><a href="/blog/java/javase/concurrent/default/原子变量与非阻塞同步机制.html" class="sidebar-link">原子变量与非阻塞同步机制</a></li><li><a href="/blog/java/javase/concurrent/default/Executor框架.html" class="sidebar-link">Executor框架</a></li><li><a href="/blog/java/javase/concurrent/default/Future框架.html" class="sidebar-link">Future框架</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/other/default/static关键字.html" class="sidebar-link">static关键字</a></li><li><a href="/blog/java/javase/other/default/泛型机制.html" class="sidebar-link">泛型机制</a></li><li><a href="/blog/java/javase/other/default/解决hash冲突的常用方法.html" class="sidebar-link">解决hash冲突的常用方法</a></li><li><a href="/blog/java/javase/other/default/三元运算符与类型转换.html" class="sidebar-link">三元运算符与类型转换</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/io/default/NIO概述.html" class="active sidebar-link">NIO概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/javase/io/default/NIO概述.html#_1-nio和bio的区别" class="sidebar-link">1. NIO和BIO的区别</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/io/default/NIO概述.html#_2-核心组件" class="sidebar-link">2. 核心组件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/javase/io/default/NIO概述.html#_2-1-buffer" class="sidebar-link">2.1 Buffer</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/io/default/NIO概述.html#_2-2-channel" class="sidebar-link">2.2 Channel</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/io/default/NIO概述.html#_2-3-selector" class="sidebar-link">2.3 Selector</a></li></ul></li></ul></li></ul></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-nio和bio的区别"><a href="#_1-nio和bio的区别" class="header-anchor">#</a> 1. NIO和BIO的区别</h2> <ol><li><p>BIO是面向流的，NIO是面向缓冲区的。</p> <p>BIO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。</p> <p>NIO则将数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p></li> <li><p>BIO的各种流是阻塞的，而NIO支持非阻塞模式IO。</p> <p>在BIO中，当一个线程调用<code>read()</code> 或 <code>write()</code>时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p> <p>NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p></li></ol> <h2 id="_2-核心组件"><a href="#_2-核心组件" class="header-anchor">#</a> 2. 核心组件</h2> <h3 id="_2-1-buffer"><a href="#_2-1-buffer" class="header-anchor">#</a> 2.1 Buffer</h3> <p>Buffer，缓冲区，实际上是一个数组容器。</p> <p>Channel从网络或者文件等读取的数据都必须经过Buffer。</p> <p><img src="/img/java/javase/io/1.1.jpg" alt="img"></p> <p>Java nio提供了多种Buffer实现，如<code>ByteBuffer</code>、<code>CharBuffer</code>、<code>DoubleBuffer</code>、<code>FloatBuffer</code>、<code>IntBuffer</code>、<code>LongBuffer</code>、<code>ShortBuffer</code>，分别对应各种基本数据类型。还有<code>MappedByteBuffer</code>、<code>HeapByteBuffer</code>、<code>DirectByteBuffer</code>等适用于特殊场景的实现。</p> <h4 id="_2-1-1-内部模型"><a href="#_2-1-1-内部模型" class="header-anchor">#</a> 2.1.1 内部模型</h4> <p>Buffer类中定义了四个变量：capacity、position、limit、mark。</p> <table><thead><tr><th style="text-align:center;">变量</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">capacity</td> <td style="text-align:center;">缓冲区数组的总长度，默认大小为数组长度</td></tr> <tr><td style="text-align:center;">position</td> <td style="text-align:center;">下一个要操作的元素的位置，默认为0</td></tr> <tr><td style="text-align:center;">limit</td> <td style="text-align:center;">缓冲区数组中不可操作的下一个元素的位置：limit&lt;=capacity，默认大小为数组长度</td></tr> <tr><td style="text-align:center;">mark</td> <td style="text-align:center;">用于记录当前position，默认为-1</td></tr></tbody></table> <p>下面，以ByteBuffer为例，通过对其常用方法进行说明，来了解上述四个变量是如何工作的。</p> <h4 id="_2-1-2-allocate"><a href="#_2-1-2-allocate" class="header-anchor">#</a> 2.1.2 allocate</h4> <p>分配指定大小的HeapByteBuffer，HeapByteBuffer属于堆缓冲区，是ByteBuffer的一种实现，也是我们常用的ByteBuffer实现，因为是在java堆内存中，所以其能被快速分配，并且能被垃圾收集器收集释放。</p> <h4 id="_2-1-2-allocatedirect"><a href="#_2-1-2-allocatedirect" class="header-anchor">#</a> 2.1.2 allocateDirect</h4> <p>分配指定大小的DirectByteBuffer，DirectByteBuffer不在堆内存中，所以不存在由于垃圾收集引起的复制操作。但是其主要缺点是分配和释放比较昂贵，并且需要程序员手动释放。</p> <p>在调用<code>ByteBuffer.allocate(11)</code>后，ByteBuffer内部数组可以用下面的图示表示：</p> <p><img src="/img/java/javase/io/1.2.png" alt="img"></p> <p>此时position=0，mark=-1，capacity=limit=10。</p> <h4 id="_2-1-3-向bytebuffer写入5个字节"><a href="#_2-1-3-向bytebuffer写入5个字节" class="header-anchor">#</a> 2.1.3 向ByteBuffer写入5个字节</h4> <p><img src="/img/java/javase/io/1.3.jpg" alt="img"></p> <p>此时position=5，mark=4，capacity=limit=10。</p> <h4 id="_2-1-4-flip"><a href="#_2-1-4-flip" class="header-anchor">#</a> 2.1.4 flip</h4> <p>通俗来理解，flip方法就是标记出当前数组中可以读取的数据。在使用中，通常要先调用flip方法，标记出ByteBuffer中可读取的数据起始和结束位置，然后将数据读取到channel中。</p> <div class="language- extra-class"><pre class="language-text"><code>public final Buffer flip() {
    limit = position;
    position = 0;
    mark = -1;
    return this;
}
</code></pre></div><p>承接上面的图示:</p> <p><img src="/img/java/javase/io/1.4.png" alt="img"></p> <h4 id="_2-1-5-clear"><a href="#_2-1-5-clear" class="header-anchor">#</a> 2.1.5 clear</h4> <p>clear方法会将position、limit、mark全部置为初始值。此时如果数组中还有未读数据，那么这些数据就会被”遗忘”，无法再获取到这些数据，并且在向数组中写入新数据时，会覆盖这些遗留数据。</p> <div class="language- extra-class"><pre class="language-text"><code>public final Buffer clear() {
    position = 0;
    limit = capacity;
    mark = -1;
    return this;
}
</code></pre></div><h4 id="_2-1-6-compact"><a href="#_2-1-6-compact" class="header-anchor">#</a> 2.1.6 compact</h4> <p>compact方法会将数组中的未读数据拷贝到数组起始处，然后将position设置为最后一位未读数据的下一步，在向数组写入新数据时，会在position处开始写入，不会覆盖掉原有的未读数据。</p> <div class="language- extra-class"><pre class="language-text"><code>public ByteBuffer compact() {
    System.arraycopy(hb, ix(position()), hb, ix(0), remaining());
    position(remaining());
    limit(capacity());
    discardMark();
    return this;
}
</code></pre></div><h4 id="_2-1-7-position"><a href="#_2-1-7-position" class="header-anchor">#</a> 2.1.7 position</h4> <p>将position置于newPosition位置，可用于读取newPosition到limit部分的数据。</p> <div class="language- extra-class"><pre class="language-text"><code>public final Buffer position(int newPosition) {
    if ((newPosition &gt; limit) || (newPosition &lt; 0))
        throw new IllegalArgumentException();
    position = newPosition;
    if (mark &gt; position) mark = -1;
    return this;
}
</code></pre></div><h4 id="_2-1-8-limit"><a href="#_2-1-8-limit" class="header-anchor">#</a> 2.1.8 limit</h4> <p>limit方法用于更新limit位置，可以用于限制读取position到newLimit之间的数据。</p> <div class="language- extra-class"><pre class="language-text"><code>public final Buffer limit(int newLimit) {
    if ((newLimit &gt; capacity) || (newLimit &lt; 0))
        throw new IllegalArgumentException();
    limit = newLimit;
    if (position &gt; limit) position = limit;
    if (mark &gt; limit) mark = -1;
    return this;
}
</code></pre></div><h4 id="_2-1-9-mark-和-reset"><a href="#_2-1-9-mark-和-reset" class="header-anchor">#</a> 2.1.9 mark 和 reset</h4> <p>mark方法会标记当前position。</p> <div class="language- extra-class"><pre class="language-text"><code>public final Buffer mark() {
    mark = position;
    return this;
}
</code></pre></div><p>reset方法用于恢复用<code>mark()</code>方法标记的position位置。</p> <div class="language- extra-class"><pre class="language-text"><code>public final Buffer reset() {
    int m = mark;
    if (m &lt; 0)
        throw new InvalidMarkException();
    position = m;
    return this;
}
</code></pre></div><h4 id="_2-1-10-rewind"><a href="#_2-1-10-rewind" class="header-anchor">#</a> 2.1.10 rewind</h4> <p>rewind方法会重置position，limit保持不变，可用于重复读取数组中的数据。</p> <div class="language- extra-class"><pre class="language-text"><code>public final Buffer rewind() {
    position = 0;
    mark = -1;
    return this;
}
</code></pre></div><h3 id="_2-2-channel"><a href="#_2-2-channel" class="header-anchor">#</a> 2.2 Channel</h3> <p>通常来说，所有的 NIO 的 I/O 操作都是从 Channel 开始的。一个 channel 类似于一个 stream。</p> <h4 id="_2-2-1-java-stream-和-nio-channel-对比"><a href="#_2-2-1-java-stream-和-nio-channel-对比" class="header-anchor">#</a> 2.2.1 java Stream 和 NIO Channel 对比</h4> <p>同一个 Channel 中可以执行读和写操作，然而同一个 Stream 仅仅支持读或写。</p> <p>Channel 可以异步地读写，而 Stream 是阻塞的同步读写。</p> <p>Channel 总是从 Buffer 中读取数据，或将数据写入到 Buffer 中。</p> <h4 id="_2-2-2-channel-类型"><a href="#_2-2-2-channel-类型" class="header-anchor">#</a> 2.2.2 Channel 类型</h4> <ol><li><p><code>FileChannel</code>：文件操作</p></li> <li><p><code>DatagramChannel</code>：UDP 操作</p></li> <li><p><code>SocketChannel</code>：TCP 操作</p></li> <li><p><code>ServerSocketChannel</code>：TCP 操作，使用在服务器端</p> <p>这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO。</p></li></ol> <h4 id="_2-2-3-使用示例"><a href="#_2-2-3-使用示例" class="header-anchor">#</a> 2.2.3 使用示例</h4> <h5 id="_2-2-3-1-文件io"><a href="#_2-2-3-1-文件io" class="header-anchor">#</a> 2.2.3.1 文件IO</h5> <p><strong>读取文件</strong></p> <div class="language- extra-class"><pre class="language-text"><code>public  static void read() throws Exception {
    RandomAccessFile file = new RandomAccessFile(&quot;C:\\Users\\Administrator\\Desktop\\jstatd.all.policy&quot;,&quot;rw&quot;);
    FileChannel channel = file.getChannel();
    ByteBuffer buffer = ByteBuffer.allocate(10);
    int i = channel.read(buffer);
    while (i != -1){
        buffer.flip();
        while (buffer.hasRemaining()){
            System.out.print((char) buffer.get());
        }
        buffer.clear();
        i = channel.read(buffer);
    }
    channel.close();
    file.close();
}
</code></pre></div><p><strong>写入文件</strong></p> <div class="language- extra-class"><pre class="language-text"><code>public static void write() throws Exception{

    RandomAccessFile file = new RandomAccessFile(&quot;C:\\Users\\Administrator\\Desktop\\aaa.txt&quot;,&quot;rw&quot;);
    FileChannel channel = file.getChannel();
    String str = &quot;i am writing some text into file! now=&quot; + System.nanoTime();
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    buffer.clear();
    buffer.put(str.getBytes(&quot;utf-8&quot;));
    buffer.flip();
    while (buffer.hasRemaining()){
        channel.write(buffer);
    }
    channel.close();
    file.close();

}
</code></pre></div><h4 id="_2-2-3-2-tcp"><a href="#_2-2-3-2-tcp" class="header-anchor">#</a> 2.2.3.2 TCP</h4> <p><strong>服务端</strong></p> <div class="language- extra-class"><pre class="language-text"><code>public static void main(String[] args) throws Exception {

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;,8181));

    while (true){
        SocketChannel socketChannel = serverSocketChannel.accept();
        if(socketChannel != null){
            System.out.println(&quot;[&quot;+System.nanoTime()+&quot;] 服务器接收到客户端消息:&quot;);
            ByteBuffer readBuffer = ByteBuffer.allocate(10);
            readBuffer.clear();

            int i = socketChannel.read(readBuffer);
            while (i != -1){
                readBuffer.flip();
                while (readBuffer.hasRemaining()){
                    System.out.print((char) readBuffer.get());
                }
                readBuffer.clear();
                i = socketChannel.read(readBuffer);
            }
        }
    }

}
</code></pre></div><p><strong>客户端</strong></p> <div class="language- extra-class"><pre class="language-text"><code>public static void main(String[] args) throws Exception {

    SocketChannel socketChannel = SocketChannel.open();
    socketChannel.configureBlocking(false);
    socketChannel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;,8181));

    while (socketChannel.finishConnect()){
        ByteBuffer writeBuffer = ByteBuffer.allocate(1024);
        writeBuffer.clear();
        writeBuffer.put((&quot;client request : &quot;+System.nanoTime()).getBytes());
        writeBuffer.flip();
        while (writeBuffer.hasRemaining()){
            socketChannel.write(writeBuffer);
        }
    }

}
</code></pre></div><h4 id="_2-2-3-3-udp"><a href="#_2-2-3-3-udp" class="header-anchor">#</a> 2.2.3.3 UDP</h4> <p><strong>发送端</strong></p> <div class="language- extra-class"><pre class="language-text"><code>public static void send() {
    try {
        DatagramChannel channel= DatagramChannel.open();
        int i = 1;
        while (i&lt;=20){
            String str = &quot;[&quot;+System.nanoTime()+&quot;] udp message&quot;;
            ByteBuffer buffer = ByteBuffer.allocate(50);
            buffer.clear();
            buffer.put(str.getBytes());
            buffer.flip();
            while (buffer.hasRemaining()){
                channel.send(buffer,new InetSocketAddress(&quot;127.0.0.1&quot;,8181));
            }
            buffer.clear();
            System.out.println(&quot;---send udp message successfully!&quot;);
            i++;
        }
    }catch (Exception e){
        e.printStackTrace();
    }
}
</code></pre></div><p><strong>接收端</strong></p> <div class="language- extra-class"><pre class="language-text"><code>public static void receive() {
    try {
        DatagramChannel channel= DatagramChannel.open();
        channel.bind(new InetSocketAddress(8181));
        int i = 1;
        while (i&lt;=20){
            ByteBuffer buffer = ByteBuffer.allocate(50);
            buffer.clear();
            channel.receive(buffer);
            System.out.print(&quot;receive udp message :&quot;);
            buffer.flip();
            while (buffer.hasRemaining()){
                System.out.print((char) buffer.get());
            }
            buffer.clear();
            System.out.println();
            i++;
        }
    }catch (Exception e){
        e.printStackTrace();
    }
}
</code></pre></div><h3 id="_2-3-selector"><a href="#_2-3-selector" class="header-anchor">#</a> 2.3 Selector</h3> <p>Selector 允许一个单一的线程来操作多个 Channel。</p> <p>如果我们的应用程序中使用了多个 Channel，那么使用 Selector 很方便的实现这样的目的，但是因为在一个线程中使用了多个 Channel，因此也会造成了每个 Channel 传输效率的降低。</p> <p>使用 Selector 的图解如下:</p> <p><img src="/img/java/javase/io/1.5.png" alt="img"></p> <h4 id="_2-3-1-使用selector"><a href="#_2-3-1-使用selector" class="header-anchor">#</a> 2.3.1 使用Selector</h4> <p><strong>创建Selector</strong></p> <div class="language- extra-class"><pre class="language-text"><code>Selector selector = Selector.open();
</code></pre></div><p><strong>将Channel注册到Selector</strong></p> <div class="language- extra-class"><pre class="language-text"><code>channel.register(selector,selectorKey) 
或 
channel.register(selector,selectorKey,attObject)
</code></pre></div><p>要将channel注册到Selector前必须保证channel是非阻塞的，register方法的第二个参数指定了我们感兴趣的事件，有四种可选值：</p> <div class="language- extra-class"><pre class="language-text"><code>SelectionKey.OP_CONNECT     //channel已连接
SelectionKey.OP_ACCEPT      //channel确认,用于tcp服务端
SelectionKey.OP_READ        //channel可读
SelectionKey.OP_WRITE       //channel可写
</code></pre></div><p>如果想要一次性指定多个感兴趣的事件，可以使用”|”运算来组合:</p> <div class="language- extra-class"><pre class="language-text"><code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;
</code></pre></div><p>注意：一个channel仅可以注册到一个Selector一次，后续注册会覆盖掉之前的注册信息。register方法可以通过第三个参数传入一个附加对象，并且能够在事件发生后获取到该对象。</p> <p><strong>获取事件</strong></p> <p>通过<code>selector.selectedKeys()</code>可以获取所有注册到Selector的所有事件，并可以通过<code>isAcceptable()</code>、<code>isConnectable()</code>、<code>isReadable()</code>、<code>isWritable()</code>来判断事件是否已经准备就绪，并且能够通过<code>channel()</code>方法获取对应的channel，如果存在附加对象，可以通过<code>attachment()</code>方法获取。</p> <p>注意：在通过<code>selectedKeys()</code>方法获取到事件集合后，如果对该事件进行了处理，那么Selector并不会删除该事件，需要手动删除。</p> <p>也可以通过<code>select()</code>方法获取准备就绪的事件个数，该方法默认阻塞等待事件就绪。可以通过<code>select(long timeout)</code>方法设置等待时间，也可以通过<code>selectNow()</code>获取，该方法不会阻塞，立刻返回结果。</p> <p>##@# 2.3.2 示例</p> <div class="language- extra-class"><pre class="language-text"><code>    public static void main(String[] args) throws IOException {
        Selector selector = Selector.open();
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        serverSocketChannel.configureBlocking(false);
        serverSocketChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;,8181));
        //注册事件
        serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);
        while (true){
            if(selector.selectNow() == 0){
                //如果没有事件准备就绪,继续下一次循环
                continue;
            }
            Iterator&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys().iterator();
            while (selectionKeys.hasNext()) {
                SelectionKey key = selectionKeys.next();
                if (key.isAcceptable()) {
                    System.out.println(&quot;新的客户端连接成功!&quot;);
                    SocketChannel channel = ((ServerSocketChannel)key.channel()).accept();
                    channel.configureBlocking(false);
                    channel.register(key.selector(),SelectionKey.OP_READ,ByteBuffer.allocate(1024));
                } else if (key.isReadable()) {
                    System.out.print(&quot;读取客户端消息:&quot;);
                    ByteBuffer buffer = (ByteBuffer) key.attachment();
                    buffer.clear();
                    SocketChannel socketChannel = (SocketChannel) key.channel();
                    socketChannel.read(buffer);
                    buffer.flip();
                    while (buffer.hasRemaining()) {
                        System.out.print((char) buffer.get());
                    }
                    buffer.clear();
                } 
                selectionKeys.remove();
            }
        }
    }
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/java/javase/other/default/三元运算符与类型转换.html" class="prev">
        三元运算符与类型转换
      </a></span> <!----></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.8d6c0f8a.js" defer></script><script src="/blog/assets/js/2.ba6b1436.js" defer></script><script src="/blog/assets/js/1.2d4ce02f.js" defer></script><script src="/blog/assets/js/95.9fc69c4a.js" defer></script>
  </body>
</html>
