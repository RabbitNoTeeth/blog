<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaSE-Set | 刘新冬的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/blog/img/logo.png">
    <meta name="description" content="JavaSE-Set">
    
    <link rel="preload" href="/blog/assets/css/0.styles.ef7b091d.css" as="style"><link rel="preload" href="/blog/assets/js/app.6e13de4b.js" as="script"><link rel="preload" href="/blog/assets/js/2.ba6b1436.js" as="script"><link rel="preload" href="/blog/assets/js/1.2d4ce02f.js" as="script"><link rel="preload" href="/blog/assets/js/82.ef0d1455.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.14082ad8.js"><link rel="prefetch" href="/blog/assets/js/100.3fe3bc9e.js"><link rel="prefetch" href="/blog/assets/js/101.b0c6af63.js"><link rel="prefetch" href="/blog/assets/js/102.f5b300a6.js"><link rel="prefetch" href="/blog/assets/js/103.1acb1fc5.js"><link rel="prefetch" href="/blog/assets/js/104.bead4590.js"><link rel="prefetch" href="/blog/assets/js/105.b3e3eda0.js"><link rel="prefetch" href="/blog/assets/js/106.34b60003.js"><link rel="prefetch" href="/blog/assets/js/107.7fb680b6.js"><link rel="prefetch" href="/blog/assets/js/108.374085fd.js"><link rel="prefetch" href="/blog/assets/js/109.e8cb0cd1.js"><link rel="prefetch" href="/blog/assets/js/11.d36ef131.js"><link rel="prefetch" href="/blog/assets/js/12.c5493e01.js"><link rel="prefetch" href="/blog/assets/js/13.430eca0c.js"><link rel="prefetch" href="/blog/assets/js/14.c88f86cd.js"><link rel="prefetch" href="/blog/assets/js/15.e1cc950a.js"><link rel="prefetch" href="/blog/assets/js/16.b699b95c.js"><link rel="prefetch" href="/blog/assets/js/17.b99ba729.js"><link rel="prefetch" href="/blog/assets/js/18.7dff4b06.js"><link rel="prefetch" href="/blog/assets/js/19.ff06d982.js"><link rel="prefetch" href="/blog/assets/js/20.7de9995c.js"><link rel="prefetch" href="/blog/assets/js/21.cb9bdcf0.js"><link rel="prefetch" href="/blog/assets/js/22.16dfd536.js"><link rel="prefetch" href="/blog/assets/js/23.bf77e72b.js"><link rel="prefetch" href="/blog/assets/js/24.e5007a9f.js"><link rel="prefetch" href="/blog/assets/js/25.c7f21645.js"><link rel="prefetch" href="/blog/assets/js/26.64d829b6.js"><link rel="prefetch" href="/blog/assets/js/27.cb93dd1f.js"><link rel="prefetch" href="/blog/assets/js/28.f119234c.js"><link rel="prefetch" href="/blog/assets/js/29.4ebed3b0.js"><link rel="prefetch" href="/blog/assets/js/3.00356991.js"><link rel="prefetch" href="/blog/assets/js/30.64faf300.js"><link rel="prefetch" href="/blog/assets/js/31.34e09941.js"><link rel="prefetch" href="/blog/assets/js/32.d97feb3b.js"><link rel="prefetch" href="/blog/assets/js/33.989013a1.js"><link rel="prefetch" href="/blog/assets/js/34.e4da7325.js"><link rel="prefetch" href="/blog/assets/js/35.31a69502.js"><link rel="prefetch" href="/blog/assets/js/36.f7df77c6.js"><link rel="prefetch" href="/blog/assets/js/37.3ff8f40c.js"><link rel="prefetch" href="/blog/assets/js/38.07773b13.js"><link rel="prefetch" href="/blog/assets/js/39.6bc6e475.js"><link rel="prefetch" href="/blog/assets/js/4.7fa5c39e.js"><link rel="prefetch" href="/blog/assets/js/40.d4372ff1.js"><link rel="prefetch" href="/blog/assets/js/41.fc9f747a.js"><link rel="prefetch" href="/blog/assets/js/42.1b630c60.js"><link rel="prefetch" href="/blog/assets/js/43.53183817.js"><link rel="prefetch" href="/blog/assets/js/44.8a25fb48.js"><link rel="prefetch" href="/blog/assets/js/45.05d8c3dc.js"><link rel="prefetch" href="/blog/assets/js/46.0dc47250.js"><link rel="prefetch" href="/blog/assets/js/47.a769691a.js"><link rel="prefetch" href="/blog/assets/js/48.0e49b5c3.js"><link rel="prefetch" href="/blog/assets/js/49.2c4b0b01.js"><link rel="prefetch" href="/blog/assets/js/5.8a935be6.js"><link rel="prefetch" href="/blog/assets/js/50.d48b16f0.js"><link rel="prefetch" href="/blog/assets/js/51.7dceb146.js"><link rel="prefetch" href="/blog/assets/js/52.b6ae0713.js"><link rel="prefetch" href="/blog/assets/js/53.046b88a2.js"><link rel="prefetch" href="/blog/assets/js/54.b5596254.js"><link rel="prefetch" href="/blog/assets/js/55.f9077d07.js"><link rel="prefetch" href="/blog/assets/js/56.7cd32adc.js"><link rel="prefetch" href="/blog/assets/js/57.07a79e6c.js"><link rel="prefetch" href="/blog/assets/js/58.3c2714d1.js"><link rel="prefetch" href="/blog/assets/js/59.2942e8a9.js"><link rel="prefetch" href="/blog/assets/js/6.c6745fa4.js"><link rel="prefetch" href="/blog/assets/js/60.2034c67b.js"><link rel="prefetch" href="/blog/assets/js/61.af320179.js"><link rel="prefetch" href="/blog/assets/js/62.a7b30842.js"><link rel="prefetch" href="/blog/assets/js/63.242b7861.js"><link rel="prefetch" href="/blog/assets/js/64.08909954.js"><link rel="prefetch" href="/blog/assets/js/65.c5c5f29e.js"><link rel="prefetch" href="/blog/assets/js/66.1f2fccf4.js"><link rel="prefetch" href="/blog/assets/js/67.6fe3be02.js"><link rel="prefetch" href="/blog/assets/js/68.6b40d6ba.js"><link rel="prefetch" href="/blog/assets/js/69.c6a9d2c9.js"><link rel="prefetch" href="/blog/assets/js/7.f127ebf8.js"><link rel="prefetch" href="/blog/assets/js/70.00b93126.js"><link rel="prefetch" href="/blog/assets/js/71.133e5d42.js"><link rel="prefetch" href="/blog/assets/js/72.cf6be888.js"><link rel="prefetch" href="/blog/assets/js/73.2cdd2145.js"><link rel="prefetch" href="/blog/assets/js/74.f55dcc81.js"><link rel="prefetch" href="/blog/assets/js/75.c48d7781.js"><link rel="prefetch" href="/blog/assets/js/76.d6244710.js"><link rel="prefetch" href="/blog/assets/js/77.6f4860be.js"><link rel="prefetch" href="/blog/assets/js/78.e9ebefa1.js"><link rel="prefetch" href="/blog/assets/js/79.693e869a.js"><link rel="prefetch" href="/blog/assets/js/80.1e0ccca6.js"><link rel="prefetch" href="/blog/assets/js/81.62dd7db1.js"><link rel="prefetch" href="/blog/assets/js/83.445b9c32.js"><link rel="prefetch" href="/blog/assets/js/84.2c72ae76.js"><link rel="prefetch" href="/blog/assets/js/85.dc69de5f.js"><link rel="prefetch" href="/blog/assets/js/86.5487c200.js"><link rel="prefetch" href="/blog/assets/js/87.27164930.js"><link rel="prefetch" href="/blog/assets/js/88.1f0b6531.js"><link rel="prefetch" href="/blog/assets/js/89.c4633f89.js"><link rel="prefetch" href="/blog/assets/js/90.ab0308ed.js"><link rel="prefetch" href="/blog/assets/js/91.e9b62cd3.js"><link rel="prefetch" href="/blog/assets/js/92.c604ad6a.js"><link rel="prefetch" href="/blog/assets/js/93.b9aed2ed.js"><link rel="prefetch" href="/blog/assets/js/94.316923a2.js"><link rel="prefetch" href="/blog/assets/js/95.85b9ac03.js"><link rel="prefetch" href="/blog/assets/js/96.868fa86d.js"><link rel="prefetch" href="/blog/assets/js/97.e9923d97.js"><link rel="prefetch" href="/blog/assets/js/98.b947130d.js"><link rel="prefetch" href="/blog/assets/js/99.73579e22.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.162bdabc.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.ef7b091d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="刘新冬的博客" class="logo"> <span class="site-name can-hide">刘新冬的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaSE</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/" aria-current="page" class="sidebar-link">简介</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>集合</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/collection/default/Collection.html" class="sidebar-link">Collection</a></li><li><a href="/blog/java/javase/collection/default/List.html" class="sidebar-link">List</a></li><li><a href="/blog/java/javase/collection/default/Map.html" class="sidebar-link">Map</a></li><li><a href="/blog/java/javase/collection/default/Queue.html" class="sidebar-link">Queue</a></li><li><a href="/blog/java/javase/collection/default/Set.html" aria-current="page" class="active sidebar-link">Set</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_1-treeset" class="sidebar-link">1. TreeSet</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_1-1-api" class="sidebar-link">1.1 API</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_2-enumset" class="sidebar-link">2. EnumSet</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_2-1-api" class="sidebar-link">2.1 API</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_2-2-regularenumset" class="sidebar-link">2.2 RegularEnumSet</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_2-3-jumboenumset" class="sidebar-link">2.3 JumboEnumSet</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_2-4-性能" class="sidebar-link">2.4 性能</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_3-hashset" class="sidebar-link">3. HashSet</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_3-1-内部实现" class="sidebar-link">3.1 内部实现</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_3-2-linkedhashset" class="sidebar-link">3.2 LinkedHashSet</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_3-3-jobstatereasons" class="sidebar-link">3.3 JobStateReasons</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_4-concurrentskiplistset" class="sidebar-link">4. ConcurrentSkipListSet</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_5-copyonwritearrayset" class="sidebar-link">5. CopyOnWriteArraySet</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_5-1-内部实现" class="sidebar-link">5.1 内部实现</a></li><li class="sidebar-sub-header"><a href="/blog/java/javase/collection/default/Set.html#_5-2-api" class="sidebar-link">5.2 API</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/concurrent/default/设计线程安全的类.html" class="sidebar-link">设计线程安全的类</a></li><li><a href="/blog/java/javase/concurrent/default/基础构建模块.html" class="sidebar-link">基础构建模块</a></li><li><a href="/blog/java/javase/concurrent/default/任务执行.html" class="sidebar-link">任务执行</a></li><li><a href="/blog/java/javase/concurrent/default/取消与关闭.html" class="sidebar-link">取消与关闭</a></li><li><a href="/blog/java/javase/concurrent/default/线程池的使用.html" class="sidebar-link">线程池的使用</a></li><li><a href="/blog/java/javase/concurrent/default/死锁.html" class="sidebar-link">死锁</a></li><li><a href="/blog/java/javase/concurrent/default/性能与可伸缩性.html" class="sidebar-link">性能与可伸缩性</a></li><li><a href="/blog/java/javase/concurrent/default/显式锁.html" class="sidebar-link">显式锁</a></li><li><a href="/blog/java/javase/concurrent/default/构建自定义的同步工具.html" class="sidebar-link">构建自定义的同步工具</a></li><li><a href="/blog/java/javase/concurrent/default/原子变量与非阻塞同步机制.html" class="sidebar-link">原子变量与非阻塞同步机制</a></li><li><a href="/blog/java/javase/concurrent/default/Executor框架.html" class="sidebar-link">Executor框架</a></li><li><a href="/blog/java/javase/concurrent/default/Future框架.html" class="sidebar-link">Future框架</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/other/default/static关键字.html" class="sidebar-link">static关键字</a></li><li><a href="/blog/java/javase/other/default/泛型机制.html" class="sidebar-link">泛型机制</a></li><li><a href="/blog/java/javase/other/default/解决hash冲突的常用方法.html" class="sidebar-link">解决hash冲突的常用方法</a></li><li><a href="/blog/java/javase/other/default/三元运算符与类型转换.html" class="sidebar-link">三元运算符与类型转换</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/java/javase/io/default/NIO概述.html" class="sidebar-link">NIO概述</a></li></ul></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p><img src="/img/java/javase/collection/1.1.png" alt=""></p> <h2 id="_1-treeset"><a href="#_1-treeset" class="header-anchor">#</a> 1. TreeSet</h2> <p>TreeSet作为一个可排序的set集合，可以按照一定的排序规则对set中保存的元素进行排序。（由于TreeSet是基于TreeMap实现的，所以本章节只是简单讲解，在TreeMap中会进行详细讲解）</p> <h3 id="_1-1-api"><a href="#_1-1-api" class="header-anchor">#</a> 1.1 API</h3> <h4 id="_1-1-1-构造函数"><a href="#_1-1-1-构造函数" class="header-anchor">#</a> 1.1.1 构造函数</h4> <div class="language- extra-class"><pre class="language-text"><code>public TreeSet() {
    this(new TreeMap&lt;E,Object&gt;());
}

public TreeSet(Comparator&lt;? super E&gt; comparator) {
    this(new TreeMap&lt;&gt;(comparator));
}
</code></pre></div><p>从TreeSet常用的两个构造器中，我们可以看出，TreeSet内部是通过维护一个TreeMap来实现的，当使用无参构造函数时，使用的是TreeMap中默认的自然顺序比较器，同时也提供了自定义比较器实现的构造函数。</p> <h4 id="_1-1-2-add添加元素"><a href="#_1-1-2-add添加元素" class="header-anchor">#</a> 1.1.2 add添加元素</h4> <div class="language- extra-class"><pre class="language-text"><code>private static final Object PRESENT = new Object();

public boolean add(E e) {
    return m.put(e, PRESENT)==null;
}
</code></pre></div><p>在TreeSet内部定义了一个常量PRESENT，每次在add添加元素时，其实是将我们想要添加的元素作为key，常量PRESENT作为value添加到map中，调用map的put()方法。</p> <h4 id="_1-1-3-其他"><a href="#_1-1-3-其他" class="header-anchor">#</a> 1.1.3 其他</h4> <p>TreeSet的add、remove等方法，内部全部调用的是TreeMap的相关方法，再查看TreeMap源码，我们可以看到，TreeMap是非同步的，如果在并发访问中map被修改，那么会抛出ConcurrentModificationException异常。</p> <h2 id="_2-enumset"><a href="#_2-enumset" class="header-anchor">#</a> 2. EnumSet</h2> <p>EnumSet 是一个与枚举类型一起使用的专用 Set 实现。枚举set中所有元素都必须来自单个枚举类型（即必须是同类型，且该类型是Enum的子类）。EnumSet有两个子类:RegularEnumSet和JumboEnumSet.</p> <h3 id="_2-1-api"><a href="#_2-1-api" class="header-anchor">#</a> 2.1 API</h3> <p>创建EnumSet</p> <div class="language- extra-class"><pre class="language-text"><code>//定义一个枚举类
public enum DemoEnum {
    JACK,ROSE,TOM,BOB,MARRY
}

//创建EnumSet的常见方法
public static void main(String[] args) {

    EnumSet&lt;DemoEnum&gt; set1 = EnumSet.noneOf(DemoEnum.class);    //创建一个空set
    EnumSet&lt;DemoEnum&gt; set2 = EnumSet.allOf(DemoEnum.class);     //创建一个set,并enum中所有元素添加到set中

    System.out.println(&quot;--------------set1-------------&quot;);
    for (DemoEnum element:set1){
        System.out.println(element);
    }

    System.out.println(&quot;--------------set2-------------&quot;);
    for (DemoEnum element:set2){
        System.out.println(element);
    }

}

输出结果:
--------------set1-------------
--------------set2-------------
JACK
ROSE
TOM
BOB
MARRY
</code></pre></div><p>EnumSet是一个抽象类，所以并不能直接使用其构造函数创建，一般通过其提供的静态工厂方法来创建，我们来看一下noneOf()方法的源码:</p> <div class="language- extra-class"><pre class="language-text"><code>public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) {
    Enum&lt;?&gt;[] universe = getUniverse(elementType);	//首先,校验elementType是否是enum,并获取其所有元素组成的数组
    if (universe == null)
        throw new ClassCastException(elementType + &quot; not an enum&quot;);
    if (universe.length &lt;= 64)	//当数组长度,也就是enum内元素个数小于等于64时,创建子类RegularEnumSet
        return new RegularEnumSet&lt;&gt;(elementType, universe);
    else			//反之,则创建子类JumboEnumSet
        return new JumboEnumSet&lt;&gt;(elementType, universe);
}
</code></pre></div><p>为什么noneOf内部会判断enum内部元素是否大于64并且创建不同的子类呢？这就涉及到EnumSet的实现原理。</p> <h3 id="_2-2-regularenumset"><a href="#_2-2-regularenumset" class="header-anchor">#</a> 2.2 RegularEnumSet</h3> <p>查看RegularEnumSet源码,发现其对内部元素的维护是通过一个long来维护的:</p> <div class="language- extra-class"><pre class="language-text"><code>private long elements = 0L;
</code></pre></div><p>查看其add方法:</p> <div class="language- extra-class"><pre class="language-text"><code>public boolean add(E e) {
    typeCheck(e);			//检查类型
    long oldElements = elements;	//获取添加前elements的long值
    elements |= (1L &lt;&lt; ((Enum&lt;?&gt;)e).ordinal());		//获取元素对应的ordinal值,将该数值对应的long的bit位更新为1
    return elements != oldElements;	//比较添加前后的值,判断元素是否已经添加过
}
</code></pre></div><p>实现原理：
RegularEnumSet内部维护了一个long值，我们知道，long类型有64个bit位，最开始每个bit位置都为0，当添加新元素时，获取新元素对应的ordinal值，将ordinal值对应的bit位更新为1，即实现了元素的存储。</p> <h3 id="_2-3-jumboenumset"><a href="#_2-3-jumboenumset" class="header-anchor">#</a> 2.3 JumboEnumSet</h3> <p>那么，当枚举元素个数大于64时，JumboEnumSet是如何做的呢?
查看源码:</p> <div class="language- extra-class"><pre class="language-text"><code>private long elements[];

public boolean add(E e) {
    typeCheck(e);

    int eOrdinal = e.ordinal();
    int eWordNum = eOrdinal &gt;&gt;&gt; 6;

    long oldElements = elements[eWordNum];
    elements[eWordNum] |= (1L &lt;&lt; eOrdinal);
    boolean result = (elements[eWordNum] != oldElements);
    if (result)
        size++;
    return result;
}
</code></pre></div><p>可以看到，当元素个数大于64后，明显一个long值不够存储了，那么便维护一个long数组。</p> <h3 id="_2-4-性能"><a href="#_2-4-性能" class="header-anchor">#</a> 2.4 性能</h3> <p>因为EnumSet内部对元素的维护是通过long的bit位，而不是数组或者链表，所以其性能很优秀，下面是一个小示例，来比较下EnumSet和HashSet的性能。</p> <p>DemoEnum中有50个元素，以50个元素为单位，进行添加和删除，然后循环50000次。</p> <div class="language- extra-class"><pre class="language-text"><code>public enum DemoEnum {
    T00,T01,T02,T03,T04,T05,T06,T07,T08,T09,
    T10,T11,T12,T13,T14,T15,T16,T17,T18,T19,
    T20,T21,T22,T23,T24,T25,T26,T27,T28,T29,
    T30,T31,T32,T33,T34,T35,T36,T37,T38,T39,
    T40,T41,T42,T43,T44,T45,T46,T47,T48,T49
}

public static void main(String[] args) {

    testEnumSet();
    testHashSet();

}

public static void testEnumSet(){
    EnumSet&lt;DemoEnum&gt; set = EnumSet.noneOf(DemoEnum.class);

    long start = System.currentTimeMillis();
    for(int x=0;x&lt;50000;x++){
        for(DemoEnum element:DemoEnum.values()){
            set.add(element);
        }
        for(DemoEnum element:DemoEnum.values()){
            set.remove(element);
        }
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;EnumSet:&quot; + (end-start) + &quot;ms&quot;);
}

public static void testHashSet(){
    HashSet&lt;DemoEnum&gt; set = new HashSet&lt;&gt;();

    long start = System.currentTimeMillis();
    for(int x=0;x&lt;50000;x++){
        for(DemoEnum element:DemoEnum.values()){
            set.add(element);
        }
        for(DemoEnum element:DemoEnum.values()){
            set.remove(element);
        }
    }
    long end = System.currentTimeMillis();
    System.out.println(&quot;HashSet:&quot; + (end-start) + &quot;ms&quot;);
}

输出结果:
EnumSet:21ms
HashSet:90ms
</code></pre></div><p>可以看到，EnumSet的性能要高于HashSet，当插入和删除的操作越频繁，其效率的提升越明显。</p> <h2 id="_3-hashset"><a href="#_3-hashset" class="header-anchor">#</a> 3. HashSet</h2> <p>HashSet，基于散列的元素不可重复集合，不保证元素在集合中的顺序，允许存入null值，其有两个常见的子类：LinkedHashSet 和 JobStateReasons。</p> <h3 id="_3-1-内部实现"><a href="#_3-1-内部实现" class="header-anchor">#</a> 3.1 内部实现</h3> <p>在HashSet源码中，我们可以看到：</p> <div class="language- extra-class"><pre class="language-text"><code>private transient HashMap&lt;E,Object&gt; map;

private static final Object PRESENT = new Object();

public HashSet() {
    map = new HashMap&lt;&gt;();
}
</code></pre></div><p>很明显，HashSet是通过内部维护一个HashMap来实现的，其增加和删除的方法也是对内部map的调用。(关于HashMap的详解请查看相关Map体系的文章，此处不加赘述)</p> <h3 id="_3-2-linkedhashset"><a href="#_3-2-linkedhashset" class="header-anchor">#</a> 3.2 LinkedHashSet</h3> <p>在HashSet中,有一个非public访问权限的构造方法:</p> <div class="language- extra-class"><pre class="language-text"><code>HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
}
</code></pre></div><p>这是为LinkedHashSet准备的，也可以很明显的看出，LinkedHashSet是通过维护一个LinkedHashMap来实现的，我们在查看LinkedHashSet源码时可以发现，其源码很简单，所有的构造函数都是对上述构造函数的调用。</p> <div class="language- extra-class"><pre class="language-text"><code>public LinkedHashSet(int initialCapacity, float loadFactor) {
    super(initialCapacity, loadFactor, true);
}

public LinkedHashSet(int initialCapacity) {
    super(initialCapacity, .75f, true);
}

public LinkedHashSet() {
    super(16, .75f, true);
}

public LinkedHashSet(Collection&lt;? extends E&gt; c) {
    super(Math.max(2*c.size(), 11), .75f, true);
    addAll(c);
}
</code></pre></div><h3 id="_3-3-jobstatereasons"><a href="#_3-3-jobstatereasons" class="header-anchor">#</a> 3.3 JobStateReasons</h3> <p>JobStateReasons 类是打印属性类，它是一个枚举值集合，提供了有关作业当前状态的额外信息，即扩充作业的 JobState 属性值的信息。
上述是Jdk API中对JobStateReasons的定义，由于在日常开发中并没有使用到过，所以此处先留白，等后面如果有了进一步的了解再补充。</p> <h2 id="_4-concurrentskiplistset"><a href="#_4-concurrentskiplistset" class="header-anchor">#</a> 4. ConcurrentSkipListSet</h2> <p>ConcurrentSkipListSet是线程安全的有序的集合，适用于高并发的场景。</p> <p>ConcurrentSkipListSet 和 TreeSet的异同点：</p> <ol><li><p>都是有序的集合。</p></li> <li><p>线程安全机制不同。</p> <p>TreeSet是非线程安全的，而ConcurrentSkipListSet是线程安全的。</p></li> <li><p>实现原理不同。</p> <p>ConcurrentSkipListSet是通过ConcurrentSkipListMap实现的，而TreeSet是通过TreeMap实现的。</p></li></ol> <p>ConcurrentSkipListSet的增删等方法，也是对内部ConcurrentSkipListMap的相关方法调用，关于ConcurrentSkipListMap的实现原理详解请查看相关Map体系的文章，此处不再做赘述。</p> <h2 id="_5-copyonwritearrayset"><a href="#_5-copyonwritearrayset" class="header-anchor">#</a> 5. CopyOnWriteArraySet</h2> <p>CopyOnWriteArraySet，是一个基于”写复制”机制的元素有序但不可重复的Set集合，是线程安全的。何为”写复制”呢？就是当集合在写入一个新元素时，创建一个内部容器的副本，向副本中添加元素，然后将内部容器的引用指向新的容器副本。即每次添加新元素都会创建一个新的内部容器。</p> <h3 id="_5-1-内部实现"><a href="#_5-1-内部实现" class="header-anchor">#</a> 5.1 内部实现</h3> <div class="language- extra-class"><pre class="language-text"><code>private final CopyOnWriteArrayList&lt;E&gt; al;

public CopyOnWriteArraySet() {
    al = new CopyOnWriteArrayList&lt;E&gt;();
}
</code></pre></div><p>CopyOnWriteArraySet是通过内部维护一个CopyOnWriteArrayList来实现的，关于CopyOnWriteArrayList，请查看List体系文章的详解，此处不做赘述。但是本篇文章会重点讲解一下CopyOnWriteArrayList中专门为CopyOnWriteArraySet而配置的方法。</p> <h3 id="_5-2-api"><a href="#_5-2-api" class="header-anchor">#</a> 5.2 API</h3> <h4 id="_5-2-1-add"><a href="#_5-2-1-add" class="header-anchor">#</a> 5.2.1 add</h4> <div class="language- extra-class"><pre class="language-text"><code>public boolean add(E e) {
    return al.addIfAbsent(e);
}

public boolean addAll(Collection&lt;? extends E&gt; c) {
    return al.addAllAbsent(c) &gt; 0;
}
</code></pre></div><p>在CopyOnWriteArraySet中，add方法并没有调用CopyOnWriteArrayList的add或者addAll方法，而是调用了特殊的addIfAbsent()或者addAllAbsent()，这两个方法是CopyOnWriteArrayList专门为CopyOnWriteArraySet准备的方法，下面我们重点看下这两个方法的实现原理。</p> <h4 id="_5-2-2-addifabsent"><a href="#_5-2-2-addifabsent" class="header-anchor">#</a> 5.2.2 addIfAbsent</h4> <div class="language- extra-class"><pre class="language-text"><code>public boolean addIfAbsent(E e) {
   Object[] snapshot = getArray();                                //首先,复制内部数组容器的一个快照副本
   return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false : //然后在快照副本中查找该元素,如果不存在,则调用私有方法addIfAbsent进行添加
         addIfAbsent(e, snapshot);
}


private boolean addIfAbsent(E e, Object[] snapshot) {
   final ReentrantLock lock = this.lock;
   lock.lock();                              //使用lock锁住,防止其他线程并发修改
   try {
      Object[] current = getArray();
      int len = current.length;
      if (snapshot != current) {            //比较当前的容器和作为参数传递进来的容器副本,如果两者不相同,说明原始容器已经被修改过
         int common = Math.min(snapshot.length, len);   //得到原始容器和容器副本各自长度,选择最小值
         for (int i = 0; i &lt; common; i++)                //遍历
            if (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))    //当原始容器中位置i的元素与要添加的元素相同,但是与副本容器中位置i的元素不同,那么说明元素已经被添加了,直接返回false
               return false;
         if (indexOf(e, current, common, len) &gt;= 0)     //在原始容器中大于角标common的位置继续查找,如果找到了要添加的元素,那么直接返回
            return false;
      }
      Object[] newElements = Arrays.copyOf(current, len + 1);    //当原始容器和容器副本相同时,说明元素未添加,那么直接更新原始容器,将其大小+1
      newElements[len] = e;     //将元素添加到数组尾部
      setArray(newElements);    //更新引用
      return true;
   } finally {
      lock.unlock();
   }
}
</code></pre></div><h4 id="_5-2-3-addallabsent"><a href="#_5-2-3-addallabsent" class="header-anchor">#</a> 5.2.3 addAllAbsent</h4> <div class="language- extra-class"><pre class="language-text"><code>public int addAllAbsent(Collection&lt;? extends E&gt; c) {
   Object[] cs = c.toArray();             //将集合转为数组
   if (cs.length == 0)
      return 0;
   final ReentrantLock lock = this.lock;
   lock.lock();
   try {
      Object[] elements = getArray();                  //获取当前容器数组
      int len = elements.length;
      int added = 0;
      for (int i = 0; i &lt; cs.length; ++i) {             //遍历传入的集合中的所有元素
         Object e = cs[i];    
         if (indexOf(e, elements, 0, len) &lt; 0 &amp;&amp;       //如果当前容器中不包含该元素,并且传入的集合数组中此元素第一次出现,那么直接添加,记录成功添加元素的个数
               indexOf(e, cs, 0, added) &lt; 0)
            cs[added++] = e;
      }
      if (added &gt; 0) {                                 //如果添加的元素个数大于0,那么创建新的数组并更新当前的容器引用到新数组
         Object[] newElements = Arrays.copyOf(elements, len + added);
         System.arraycopy(cs, 0, newElements, len, added);
         setArray(newElements);
      }
      return added;
   } finally {
      lock.unlock();
   }
}
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/java/javase/collection/default/Queue.html" class="prev">
        Queue
      </a></span> <span class="next"><a href="/blog/java/javase/concurrent/default/设计线程安全的类.html">
        设计线程安全的类
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/blog/assets/js/app.6e13de4b.js" defer></script><script src="/blog/assets/js/2.ba6b1436.js" defer></script><script src="/blog/assets/js/1.2d4ce02f.js" defer></script><script src="/blog/assets/js/82.ef0d1455.js" defer></script>
  </body>
</html>
