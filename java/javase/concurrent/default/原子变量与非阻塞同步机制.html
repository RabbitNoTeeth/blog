<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原子变量与非阻塞同步机制 | 刘新冬的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/img/logo.png">
    <meta name="description" content="原子变量与非阻塞同步机制">
    
    <link rel="preload" href="/assets/css/0.styles.7ecebcba.css" as="style"><link rel="preload" href="/assets/js/app.a38c516a.js" as="script"><link rel="preload" href="/assets/js/2.ba6b1436.js" as="script"><link rel="preload" href="/assets/js/1.2d4ce02f.js" as="script"><link rel="preload" href="/assets/js/85.441841fb.js" as="script"><link rel="prefetch" href="/assets/js/10.14082ad8.js"><link rel="prefetch" href="/assets/js/100.2a4f0938.js"><link rel="prefetch" href="/assets/js/101.8a62150f.js"><link rel="prefetch" href="/assets/js/102.35a7e2ea.js"><link rel="prefetch" href="/assets/js/103.faae61d0.js"><link rel="prefetch" href="/assets/js/104.c27f3d0b.js"><link rel="prefetch" href="/assets/js/105.9326a988.js"><link rel="prefetch" href="/assets/js/106.3dc22e61.js"><link rel="prefetch" href="/assets/js/107.0ceb8376.js"><link rel="prefetch" href="/assets/js/108.c36e9500.js"><link rel="prefetch" href="/assets/js/11.d36ef131.js"><link rel="prefetch" href="/assets/js/12.c5493e01.js"><link rel="prefetch" href="/assets/js/13.430eca0c.js"><link rel="prefetch" href="/assets/js/14.c88f86cd.js"><link rel="prefetch" href="/assets/js/15.e1cc950a.js"><link rel="prefetch" href="/assets/js/16.b699b95c.js"><link rel="prefetch" href="/assets/js/17.b99ba729.js"><link rel="prefetch" href="/assets/js/18.7dff4b06.js"><link rel="prefetch" href="/assets/js/19.ff06d982.js"><link rel="prefetch" href="/assets/js/20.7de9995c.js"><link rel="prefetch" href="/assets/js/21.cb9bdcf0.js"><link rel="prefetch" href="/assets/js/22.16dfd536.js"><link rel="prefetch" href="/assets/js/23.eb560dbc.js"><link rel="prefetch" href="/assets/js/24.661e2539.js"><link rel="prefetch" href="/assets/js/25.c7f21645.js"><link rel="prefetch" href="/assets/js/26.64d829b6.js"><link rel="prefetch" href="/assets/js/27.4b3a16c0.js"><link rel="prefetch" href="/assets/js/28.2692df26.js"><link rel="prefetch" href="/assets/js/29.ce82418b.js"><link rel="prefetch" href="/assets/js/3.00356991.js"><link rel="prefetch" href="/assets/js/30.2051ef3b.js"><link rel="prefetch" href="/assets/js/31.34e09941.js"><link rel="prefetch" href="/assets/js/32.e50cc8ec.js"><link rel="prefetch" href="/assets/js/33.9461dbb1.js"><link rel="prefetch" href="/assets/js/34.e4da7325.js"><link rel="prefetch" href="/assets/js/35.a13a0b57.js"><link rel="prefetch" href="/assets/js/36.06d083bd.js"><link rel="prefetch" href="/assets/js/37.f7918bab.js"><link rel="prefetch" href="/assets/js/38.86961f10.js"><link rel="prefetch" href="/assets/js/39.8113a23c.js"><link rel="prefetch" href="/assets/js/4.7fa5c39e.js"><link rel="prefetch" href="/assets/js/40.434f5479.js"><link rel="prefetch" href="/assets/js/41.a4cbee5e.js"><link rel="prefetch" href="/assets/js/42.351f521c.js"><link rel="prefetch" href="/assets/js/43.5f3ad053.js"><link rel="prefetch" href="/assets/js/44.d88da63e.js"><link rel="prefetch" href="/assets/js/45.a9b5d36b.js"><link rel="prefetch" href="/assets/js/46.845f8e9a.js"><link rel="prefetch" href="/assets/js/47.50e3be7d.js"><link rel="prefetch" href="/assets/js/48.cb688c31.js"><link rel="prefetch" href="/assets/js/49.e239b0d8.js"><link rel="prefetch" href="/assets/js/5.8a935be6.js"><link rel="prefetch" href="/assets/js/50.7729a443.js"><link rel="prefetch" href="/assets/js/51.a5bfe490.js"><link rel="prefetch" href="/assets/js/52.94334c08.js"><link rel="prefetch" href="/assets/js/53.6c2661e4.js"><link rel="prefetch" href="/assets/js/54.9b31e7a4.js"><link rel="prefetch" href="/assets/js/55.4fac431c.js"><link rel="prefetch" href="/assets/js/56.a00bf0ab.js"><link rel="prefetch" href="/assets/js/57.92ae460e.js"><link rel="prefetch" href="/assets/js/58.f7f0da5f.js"><link rel="prefetch" href="/assets/js/59.7e810fa1.js"><link rel="prefetch" href="/assets/js/6.c6745fa4.js"><link rel="prefetch" href="/assets/js/60.ea3fa83f.js"><link rel="prefetch" href="/assets/js/61.d78f5084.js"><link rel="prefetch" href="/assets/js/62.bd986f10.js"><link rel="prefetch" href="/assets/js/63.ae3536c2.js"><link rel="prefetch" href="/assets/js/64.492fcc89.js"><link rel="prefetch" href="/assets/js/65.2ebe492f.js"><link rel="prefetch" href="/assets/js/66.b9c8f37b.js"><link rel="prefetch" href="/assets/js/67.1d25c263.js"><link rel="prefetch" href="/assets/js/68.3b9d23fa.js"><link rel="prefetch" href="/assets/js/69.2816cb57.js"><link rel="prefetch" href="/assets/js/7.f127ebf8.js"><link rel="prefetch" href="/assets/js/70.ac77f002.js"><link rel="prefetch" href="/assets/js/71.0be7a2dd.js"><link rel="prefetch" href="/assets/js/72.6b6c0f37.js"><link rel="prefetch" href="/assets/js/73.6fd98879.js"><link rel="prefetch" href="/assets/js/74.07e6199b.js"><link rel="prefetch" href="/assets/js/75.496aef35.js"><link rel="prefetch" href="/assets/js/76.85cd6aca.js"><link rel="prefetch" href="/assets/js/77.1e1f6d01.js"><link rel="prefetch" href="/assets/js/78.386f7748.js"><link rel="prefetch" href="/assets/js/79.c73f26bb.js"><link rel="prefetch" href="/assets/js/80.73e2f1b9.js"><link rel="prefetch" href="/assets/js/81.374b0aea.js"><link rel="prefetch" href="/assets/js/82.8ea9351f.js"><link rel="prefetch" href="/assets/js/83.9367f8bf.js"><link rel="prefetch" href="/assets/js/84.9b0667ae.js"><link rel="prefetch" href="/assets/js/86.b33f285d.js"><link rel="prefetch" href="/assets/js/87.1204c179.js"><link rel="prefetch" href="/assets/js/88.51fe8179.js"><link rel="prefetch" href="/assets/js/89.94101060.js"><link rel="prefetch" href="/assets/js/90.e4ce6df4.js"><link rel="prefetch" href="/assets/js/91.c14bd802.js"><link rel="prefetch" href="/assets/js/92.bac05565.js"><link rel="prefetch" href="/assets/js/93.98011bc4.js"><link rel="prefetch" href="/assets/js/94.614bbf82.js"><link rel="prefetch" href="/assets/js/95.9fc69c4a.js"><link rel="prefetch" href="/assets/js/96.09e8cb5f.js"><link rel="prefetch" href="/assets/js/97.adbe6a5a.js"><link rel="prefetch" href="/assets/js/98.9b0a2ee0.js"><link rel="prefetch" href="/assets/js/99.6806f377.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.162bdabc.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7ecebcba.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="刘新冬的博客" class="logo"> <span class="site-name can-hide">刘新冬的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaSE</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/javase/" aria-current="page" class="sidebar-link">简介</a></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>集合</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/javase/collection/default/Collection.html" class="sidebar-link">Collection</a></li><li><a href="/java/javase/collection/default/List.html" class="sidebar-link">List</a></li><li><a href="/java/javase/collection/default/Map.html" class="sidebar-link">Map</a></li><li><a href="/java/javase/collection/default/Queue.html" class="sidebar-link">Queue</a></li><li><a href="/java/javase/collection/default/Set.html" class="sidebar-link">Set</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading open"><span>并发</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/javase/concurrent/default/设计线程安全的类.html" class="sidebar-link">设计线程安全的类</a></li><li><a href="/java/javase/concurrent/default/基础构建模块.html" class="sidebar-link">基础构建模块</a></li><li><a href="/java/javase/concurrent/default/任务执行.html" class="sidebar-link">任务执行</a></li><li><a href="/java/javase/concurrent/default/取消与关闭.html" class="sidebar-link">取消与关闭</a></li><li><a href="/java/javase/concurrent/default/线程池的使用.html" class="sidebar-link">线程池的使用</a></li><li><a href="/java/javase/concurrent/default/死锁.html" class="sidebar-link">死锁</a></li><li><a href="/java/javase/concurrent/default/性能与可伸缩性.html" class="sidebar-link">性能与可伸缩性</a></li><li><a href="/java/javase/concurrent/default/显式锁.html" class="sidebar-link">显式锁</a></li><li><a href="/java/javase/concurrent/default/构建自定义的同步工具.html" class="sidebar-link">构建自定义的同步工具</a></li><li><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html" class="active sidebar-link">原子变量与非阻塞同步机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html#_1-硬件对并发的支持" class="sidebar-link">1. 硬件对并发的支持</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html#_1-1-比较并交换-cas" class="sidebar-link">1.1 比较并交换(CAS)</a></li><li class="sidebar-sub-header"><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html#_1-2-非阻塞的计数器" class="sidebar-link">1.2 非阻塞的计数器</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html#_2-原子变量" class="sidebar-link">2. 原子变量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html#_2-1-原子变量是一种-更好的volatile" class="sidebar-link">2.1 原子变量是一种”更好的volatile”</a></li><li class="sidebar-sub-header"><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html#_2-2-性能比较-锁与原子变量" class="sidebar-link">2.2 性能比较：锁与原子变量</a></li></ul></li><li class="sidebar-sub-header"><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html#_3-非阻塞算法" class="sidebar-link">3. 非阻塞算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html#_3-1-非阻塞的栈" class="sidebar-link">3.1 非阻塞的栈</a></li><li class="sidebar-sub-header"><a href="/java/javase/concurrent/default/原子变量与非阻塞同步机制.html#_3-2-非阻塞的链表" class="sidebar-link">3.2 非阻塞的链表</a></li></ul></li></ul></li><li><a href="/java/javase/concurrent/default/Executor框架.html" class="sidebar-link">Executor框架</a></li><li><a href="/java/javase/concurrent/default/Future框架.html" class="sidebar-link">Future框架</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/javase/other/default/static关键字.html" class="sidebar-link">static关键字</a></li><li><a href="/java/javase/other/default/泛型机制.html" class="sidebar-link">泛型机制</a></li><li><a href="/java/javase/other/default/解决hash冲突的常用方法.html" class="sidebar-link">解决hash冲突的常用方法</a></li><li><a href="/java/javase/other/default/三元运算符与类型转换.html" class="sidebar-link">三元运算符与类型转换</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>IO</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java/javase/io/default/NIO概述.html" class="sidebar-link">NIO概述</a></li></ul></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>独占锁的劣势：线程在挂起和恢复等过程中存在很大的开销。同时，当一个线程在等待锁时，无法做其他任何事情。</p> <p>与锁相比，volatile是一种更轻量级的同步机制，但是却不能用于构建原子的复合操作。当一个变量依赖其他变量时，或者当变量的新值依赖于旧值时，就不能使用volatile变量。</p> <h2 id="_1-硬件对并发的支持"><a href="#_1-硬件对并发的支持" class="header-anchor">#</a> 1. 硬件对并发的支持</h2> <h3 id="_1-1-比较并交换-cas"><a href="#_1-1-比较并交换-cas" class="header-anchor">#</a> 1.1 比较并交换(CAS)</h3> <p>在大多数处理器架构中采用的方法是实现一个比较并交换(CAS)指令。</p> <p>CAS包含3个操作数：①需要读写的内存位置V  ②进行比较的值A  ③拟写入的新值B。</p> <p>CAS的含义是：我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少。</p> <div class="language- extra-class"><pre class="language-text"><code>****** 程序清单15-1 模拟CAS操作 ******

public class SimulatedCAS{
    private int value;
    
    private synchronized int get(){
        return value;
    }
    
    public synchronized int compareAndSwap(int expectedValue,int newValue){
        int oldValue = value;
        if(oldValue == expectedValue)
            value = newValue;
        return oldValue;
    }
    
    public synchronized boolean compareAndSet(int expectedValue,int newValue){
        return expectedValue == compareAndSwap(expectedValue,newValue);
    }
}
</code></pre></div><p>当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他线程都将失败，但是失败的线程不会被挂起，而是被告知在这次竞争中失败，并可以再次尝试。由于一个线程在竞争CAS时失败不会阻塞，因此它可以决定是否重新尝试，或者执行一些恢复操作，也或者不执行任何操作。</p> <p>CAS的典型使用模式是：首先从V中读取值A，并根据A值计算出B值，然后通过CAS以原子方式将V中的值由A更新为B。</p> <p>CAS的主要缺点是：它将使调用者处理竞争问题（重试、回退、放弃等），而在锁中能自动处理竞争问题（即线程在获取锁之前一直阻塞）。</p> <h3 id="_1-2-非阻塞的计数器"><a href="#_1-2-非阻塞的计数器" class="header-anchor">#</a> 1.2 非阻塞的计数器</h3> <div class="language- extra-class"><pre class="language-text"><code>****** 程序清单15-2 基于CAS实现的非阻塞计数器 ******

public class CasCounter{
    private SimulatedCAS value;
    
    public int getValue(){
        return value.get();
    }
    
    public int increment(){
        int v;
        do {
            v = value.get();
        }while (v != value.compareAndSwap(v,v+1));
        return v+1;
    }
}
</code></pre></div><p>CasCounter不会阻塞，如果CAS失败，那么该操作将立即重试。通常，反复地重试是一种合理的策略，但是当竞争很激烈的情况下，更好的方式是在重试之前首先等待一段时间或者回退，从而避免造成活锁问题。</p> <h2 id="_2-原子变量"><a href="#_2-原子变量" class="header-anchor">#</a> 2. 原子变量</h2> <p>原子变量相当于一种泛化的volatile变量，能够支持原子的和有条件的读-改-写操作。</p> <p>共有12个原子变量类，可以分为4组：标量类、更新器类、数组类以及复合变量类。</p> <p>最常用的原子变量就是标量类：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code>和<code>AtomicReference</code>。</p> <h3 id="_2-1-原子变量是一种-更好的volatile"><a href="#_2-1-原子变量是一种-更好的volatile" class="header-anchor">#</a> 2.1 原子变量是一种”更好的volatile”</h3> <div class="language- extra-class"><pre class="language-text"><code>****** 程序清单15-3 通过CAS来维持包含多个变量的不变性条件 ******

public class CasNumberRange{
    private static class IntPair{
        final int lower;
        final int upper;
        IntPair(int lower,int upper){
            this.lower = lower;
            this.upper = upper;
        }
    }
    
    private final AtomicReference&lt;IntPair&gt; values = new AtomicReference&lt;&gt;(new IntPair(0,0));
    
    public int getLower(){ return values.get().lower; }
    public int getUpper(){ return values.get().upper; }
    
    public void setLower(int i){
        while (true){
            IntPair oldV = values.get();
            if(i&gt;oldV.upper){
                throw new RuntimeException();
            }
            IntPair newV = new IntPair(i,oldV.upper);
            if(values.compareAndSet(oldV,newV))
                return;
        }
    }
}
</code></pre></div><h3 id="_2-2-性能比较-锁与原子变量"><a href="#_2-2-性能比较-锁与原子变量" class="header-anchor">#</a> 2.2 性能比较：锁与原子变量</h3> <p>在实际情况中，原子变量在可伸缩性上要高于锁，因为在应对常见的竞争程度时，原子变量的效率会更高。</p> <p>在中低程度的竞争下，原子变量能提供更高的可伸缩性，而在高强度竞争下，锁能更有效的避免竞争。</p> <h2 id="_3-非阻塞算法"><a href="#_3-非阻塞算法" class="header-anchor">#</a> 3. 非阻塞算法</h2> <p>如果在某种算法中，一个线程的失败或挂起不会导致其他线程也失败或者挂起，那么这种算法就称为非阻塞算法。</p> <p>如果在算法的每个步骤中都存在某个线程能够执行下去，那么这种算法也称为无锁算法。</p> <h3 id="_3-1-非阻塞的栈"><a href="#_3-1-非阻塞的栈" class="header-anchor">#</a> 3.1 非阻塞的栈</h3> <div class="language- extra-class"><pre class="language-text"><code>****** 使用Treiber算法构造的非阻塞栈 ******

public class ConcurrentStatck&lt;E&gt;{
    
    AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;Node&lt;E&gt;&gt;();
    
    private class Node&lt;E&gt;{
        public final E item;
        public Node&lt;E&gt; next;
        public Node(E item){
            this.item = item;
        }
    }
    
    public void push(E item){
        Node&lt;E&gt; newHead = new Node&lt;&gt;(item);
        Node&lt;E&gt; oldHead;
        do {
            oldHead = top.get();
            newHead.next = oldHead;
        }while (!top.compareAndSet(oldHead,newHead));
    }
    
    public E pop(){
        Node&lt;E&gt; oldHead;
        Node&lt;E&gt; newHead;
        do {
            oldHead = top.get();
            if(oldHead == null)
                return null;
            newHead = oldHead.next;
        }while (!top.compareAndSet(oldHead,newHead));
        return oldHead.item;
    }
}
</code></pre></div><h3 id="_3-2-非阻塞的链表"><a href="#_3-2-非阻塞的链表" class="header-anchor">#</a> 3.2 非阻塞的链表</h3> <p>链接队列比栈更为复杂，因为它必须支持对头节点和尾节点的快速访问，因此它需要单独维护头指针和尾指针。</p> <p>有两个指针指向位于尾部的节点，当前最后一个元素的next指针以及尾节点，当成功的插入一个新元素时，这两个指针都需要采用原子操作的更新。初看起来，这个操作无法通过原子变量来实现，在更新这两个指针时需要不同的CAS操作，并且如果第一个CAS成功，但第二个CAS失败，那么队列将处于不一致的状态，而且如果这两个CAS都成功了，那么在执行这两个CAS之间，仍有可能有另一个线程会访问这个队列，因此，在为链接队列构建非阻塞算法时，需要考虑到这两种情况。</p> <p>我们可以使用两个技巧来解决上述问题：</p> <ol><li>即使在一个包含多个步骤的更新操作中，也要确保数据结构总是处于一致的状态，这样当线程b到达时，如果发现线程a正在执行更新，那么线程b就可以知道有一个操作已部分完成，并且不能立即开始执行自己的更新操作，然后b可以等待，并直到a完成更新，从而使两个线程不会相互干扰。</li> <li>如果当b到达时，发现a正在修改数据结构，那么在数据结构中应该有足够多的信息，使得b能够完成a的更新操作，如果b帮助a完成了更新操作，那么b可以执行自己的操作，而不用等待a的完成，但a恢复后再试图完成其操作时，会发现b已经替它完成了。</li></ol> <div class="language- extra-class"><pre class="language-text"><code>****** 程序清单15-7 Michael-Scott非阻塞算法中的插入算法 ******

public class LinkedQueue&lt;E&gt;{
    private class Node&lt;E&gt;{
        final E item;
        final AtomicReference&lt;Node&lt;E&gt;&gt; next;
        public Node(E item,Node&lt;E&gt; next){
            this.item = item;
            this.next = new AtomicReference&lt;&gt;(next);
        }
    }

    private final Node&lt;E&gt; dummy = new Node&lt;&gt;(null,null);
    private final AtomicReference&lt;Node&lt;E&gt;&gt; head = new AtomicReference&lt;&gt;(dummy);
    private final AtomicReference&lt;Node&lt;E&gt;&gt; tail = new AtomicReference&lt;&gt;(dummy);

    public boolean put(E item){
        Node&lt;E&gt; newNode = new Node&lt;&gt;(item,null);
        while (true){
            Node&lt;E&gt; currentTail = tail.get();
            Node&lt;E&gt; tailNext = currentTail.next.get();
            if(currentTail == tail.get()){                                        // A
                if(tailNext != null){           
                    // 队列处于中间状态,推进尾节点
                    tail.compareAndSet(currentTail,tailNext);                       // B
                }else{
                    // 队列处于稳定状态,尝试插入新节点
                    if(currentTail.next.compareAndSet(null,newNode)){       // C
                        // 插入操作成功,尝试推进尾节点
                        tail.compareAndSet(currentTail,newNode);                    // D
                        return true;
                    }
                }
            }
        }
    }
}
</code></pre></div><p>实现上面两个技巧的关键点在于：当队列处于稳定状态时，尾节点的next域将为空，如果队列处于中间状态，那么tail.next将为非空，因此任何线程都能够通过检查tail.next来获取队列当前的状态，而且当队列处于中间状态时，可以通过将尾节点向前移动一个节点，从而结束其他线程正在执行的插入元素操作，并使得队列恢复为稳定状态。</p> <p>put方法在插入新元素之前，将首先检查队列是否处于中间状态(步骤A)，如果是，那么有另一个线程正在执行插入元素(在步骤C和D之间)，此时当前线程不会等待其他线程执行完成，而是帮助它完成操作，并将尾节点向前推进一个节点(步骤B)，然后它将重复执行这种检查，以免另一个线程已经开始插入新元素，并继续推进尾节点，直到它发现队列处于稳定状态之后，才会开始执行自己的插入操作。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java/javase/concurrent/default/构建自定义的同步工具.html" class="prev">
        构建自定义的同步工具
      </a></span> <span class="next"><a href="/java/javase/concurrent/default/Executor框架.html">
        Executor框架
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.a38c516a.js" defer></script><script src="/assets/js/2.ba6b1436.js" defer></script><script src="/assets/js/1.2d4ce02f.js" defer></script><script src="/assets/js/85.441841fb.js" defer></script>
  </body>
</html>
