(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{384:function(t,a,s){"use strict";s.r(a);var r=s(7),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("java在1.5版本中引入了泛型，java中的泛型是通过擦除机制实现的，这是为了兼容1.5版本之前的类库。")]),t._v(" "),a("h2",{attrs:{id:"_1-何为擦除机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-何为擦除机制"}},[t._v("#")]),t._v(" 1. 何为擦除机制")]),t._v(" "),a("p",[t._v("擦除即在使用泛型时，任何具体的类型信息在运行期间都会被擦除，对泛型中类型的检查只发生在编译阶段。任何泛型类在运行期间都不具有泛型信息。")]),t._v(" "),a("p",[t._v("我们以一个非常简单的示例来演示擦除机制：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public static void main(String[] args) {\n    \n    List<String> list1 = new ArrayList<>();\n    List<Integer> list2 = new ArrayList<>();\n\n    System.out.println(list1.getClass());\n    System.out.println(list2.getClass());\n    System.out.println(list1.getClass().equals(list2.getClass()));\n\n}\n\n输出结果：\nclass java.util.ArrayList\nclass java.util.ArrayList\ntrue\n")])])]),a("p",[t._v("在上面的示例代码中，我们创建了两个不同的泛型List集合，如果java中的泛型不是擦除机制，那么list1和list2应该是两个不同的class类型，但是在打印的结果中，可以看到list1和list2编译后不包含任何泛型类型信息，两者编译后的class类型是相同的，都是原生的ArrayList类型。这就是擦除机制的简单演示，任何泛型代码在编译后，是不具有泛型类型信息的。")]),t._v(" "),a("p",[t._v("为什么java选择了擦除机制？如果允许泛型类在运行时携带泛型类型信息，那么在运行时获取泛型信息会相当的方便，但是java是在1.5版本中才添加了泛型的特性，如果允许在运行时携带泛型信息，那么1.5版本之前的类库将与新版本的类库不再兼容，这会带来相当大的代价。 所以，为了向前兼容，java选择了擦除机制。")]),t._v(" "),a("h2",{attrs:{id:"_2-擦除的代价"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-擦除的代价"}},[t._v("#")]),t._v(" 2. 擦除的代价")]),t._v(" "),a("p",[t._v("虽然java泛型的擦除机制解决了向前兼容的问题，但是也带来了很明显的问题：泛型不能用于显式地引用运行时类型的操作中，例如转型、instanseof 和new表达式（如 xxx instanseof T 或 new T() 等）。这是因为所有关于参数的类型信息都被擦除了，无论何时，当我们在编写泛型代码时，必须提醒自己，我们只是看起来好像拥有有关参数的类型信息而已。")]),t._v(" "),a("h2",{attrs:{id:"_3-何为边界"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-何为边界"}},[t._v("#")]),t._v(" 3. 何为边界")]),t._v(" "),a("p",[t._v("看完上面的内容，我们会存在一个非常明显得困惑：既然擦除机制在代码运行期间抹除了参数类型信息，那么java是如何保证运行期间泛型类中参数类型的正确性呢？")]),t._v(" "),a("p",[t._v("虽然擦除机制在方法和类内部抹除了参数的类型信息，但是编译器通过边界来保证泛型类和方法内部类型的一致性。 所谓边界，就是对象进入和离开方法的地点。最常见的如getter和setter方法。编译器在边界处进行所有的泛型操作：即对传递进来的值进行类型检查，对传递出去的值进行转型。")]),t._v(" "),a("h2",{attrs:{id:"_4-泛型数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-泛型数组"}},[t._v("#")]),t._v(" 4. 泛型数组")]),t._v(" "),a("p",[t._v("关于泛型数组，有几点要非常注意：")]),t._v(" "),a("ol",[a("li",[t._v("首先，不能直接创建泛型数组，想要创建泛型数组，就要先创建被擦除类型的新数组，然后对其转型。")]),t._v(" "),a("li",[t._v("对于在泛型中创建数组，推荐使用Array.newInstance()，然后将其转型。")]),t._v(" "),a("li",[t._v("多数情况下，如果需要使用泛型数组，可以考虑使用泛型ArrayList来代替。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);