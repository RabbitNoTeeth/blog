(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{332:function(e,n,t){"use strict";t.r(n);var a=t(7),s=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("虽然Java的垃圾回收使得我们从手工管理内存中解脱出来，但是在有些情况下，我们可能依旧需要自己手动管理内存，如维护一个基于数组的散列桶、实现分段锁等，此时我们就需要考虑内存管理。")]),e._v(" "),n("h2",{attrs:{id:"_1-过期引用引起的内存泄露"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-过期引用引起的内存泄露"}},[e._v("#")]),e._v(" 1. 过期引用引起的内存泄露")]),e._v(" "),n("p",[e._v("下面是一个简单的栈实现:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class Stack {\n    \n    private Object[] elements;\n    private int size = 0;\n    private static final int DEFAULT_INIT_CAPACITY = 16;\n    \n    public Stack(){\n        elements = new Object[DEFAULT_INIT_CAPACITY];\n    }\n    \n    public void push(Object element){\n        ensureCapacity();\n        elements[size++] = element;\n    }\n    \n    public Object pop(){\n        if(size == 0){\n            throw new RuntimeException();\n        }\n        return elements[--size];\n    }\n\n    private void ensureCapacity() {\n        if(elements.length == size){\n            elements = Arrays.copyOf(elements,2*size+1);\n        }\n    }\n\n}\n")])])]),n("p",[e._v("上述程序没有明显的错误，但是严格的讲，这段程序存在”内存泄露”，随着内存占用的不断增加，程序性能的降低将越来越明显。")]),e._v(" "),n("p",[e._v("哪里发生了内存泄露呢?\n当栈先增长，后收缩。那么从栈中弹出来的对象将不会被当作垃圾回收，因为栈内部维护着对这些对象的过期引用。")]),e._v(" "),n("p",[e._v("如何修复?\n一旦对象引用已经过期,清空这些引用")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public Object pop(){\n    if(size == 0){\n        throw new RuntimeException();\n    }\n    Object element = elements[--size];\n    elements[size] = null;      //清空引用\n    return element;\n}\n")])])]),n("h2",{attrs:{id:"_2-缓存引起的内存泄露"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存引起的内存泄露"}},[e._v("#")]),e._v(" 2. 缓存引起的内存泄露")]),e._v(" "),n("p",[e._v("内存泄露的另一个常见来源就是缓存。放入缓存中的对象很容易被遗忘，这使得它们不再有用之后很长一段时间仍然停留在缓存中。对于这个问题，有几种可能的解决方案：")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("WeakHashMap\n如果你的缓存有这样的需求：只有在缓存之外存在对某个键值引用，其对应的对象才有意义，那么就可以使用WeakHashMap。当缓存中的项过期后(键值不存在引用)，它们就会被自动删除。也就是说，只有当所要的缓存项的生命周期是由该键的外部引用而不是值决定时，WeakHashMap才有用处。")])]),e._v(" "),n("li",[n("p",[e._v("LinkedHashMap\n当想要通过在给缓存添加新条目时进行过期条目的清理时，LinkedHashMap的removeEldesEntry方法可以很容易的实现。")])]),e._v(" "),n("li",[n("p",[e._v("ScheduledThreadPoolExecutor\n可以通过ScheduledThreadPoolExecutor来创建后台线程进行定时的过期缓存清理。")])])]),e._v(" "),n("h2",{attrs:{id:"_3-监听器和回调引起的内存泄露"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-监听器和回调引起的内存泄露"}},[e._v("#")]),e._v(" 3. 监听器和回调引起的内存泄露")]),e._v(" "),n("p",[e._v("如果你实现了一个api，客户端在这个api中注册回调，却没有显示地取消注册，那么除非你采取某些动作，否则他们就会积聚，从而引起内存泄露。确保回调立即被当作垃圾回收的最佳方法是只保存它们的弱引用，例如只将它们保存成WeakHashMap中的键。")])])}),[],!1,null,null,null);n.default=s.exports}}]);