(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{370:function(e,n,t){"use strict";t.r(n);var a=t(7),r=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("Future 表示异步计算的结果。")]),e._v(" "),n("p",[e._v("它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。取消则由 cancel 方法来执行。还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future<?> 形式类型、并返回 null 作为底层任务的结果。")]),e._v(" "),n("p",[e._v("Future通常与Executor框架一起使用，作为整个异步框架体系中的重要成员。下面是Future框架的结构图：")]),e._v(" "),n("p",[n("img",{attrs:{src:"/img/java/javase/concurrent/2.1.png",alt:"img"}})]),e._v(" "),n("h2",{attrs:{id:"_1-future"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-future"}},[e._v("#")]),e._v(" 1. Future")]),e._v(" "),n("p",[e._v("作为Future框架的顶层接口，Future接口中定义了获取异步执行结果、取消异步任务以及获取异步任务状态的方法。")]),e._v(" "),n("p",[n("strong",[e._v("源码解读")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public interface Future<V> {\n\n    /**\n     * 尝试取消任务的执行。如果任务已经完成、或者已经被取消、或者由于其他的原因不可以取消，那么将返回false；\n     * 如果任务在取消时还未启动，那么任务将永远不会执行；\n     * 如果任务在取消时已经启动了，该方法的参数mayInterruptIfRunning为true时，会直接中断执行任务的线程来强制取消任务，该方法返回后，客户端调用isDone方法会返回true，也就是说，被取消的任务也视为完成状态。\n     * 只有该方法返回true时，客户端调用isCancelled方法才会返回true\n     *\n     * @param mayInterruptIfRunning 如果任务正在执行，该值为true时，会直接中断执行任务的线程来强制取消任务；\n     *                              值为false时，会等待任务执行完毕\n     * @return 是否取消成功\n     */\n    boolean cancel(boolean mayInterruptIfRunning);\n\n    /**\n     * 如果任务在完成前就被取消了，那么返回true；否则返回false\n     */\n    boolean isCancelled();\n\n    /**\n     * 如果任务已经完成，那么返回true；否则返回false\n     * 无论任务是被取消还是正常执行完毕，都会返回true；\n     */\n    boolean isDone();\n\n    /**\n     * 获取异步任务的执行结果（如果任务未执行完，那么等待任务执行完毕）\n     *\n     * @return 异步执行结果\n     * @throws CancellationException 如果任务执行时被取消，那么抛出该异常\n     * @throws ExecutionException 如果任务代码执行时发生异常，那么抛出该异常，客户端可以\n     *                            通过捕获该异常，该异常中记录了务代码执行时发生的异常\n     * @throws InterruptedException 如果在等待时，当前线程被中断，那么抛出该异常\n     */\n    V get() throws InterruptedException, ExecutionException;\n\n    /**\n     * 获取异步任务的执行结果（如果任务未执行完，那么等待任务执行完毕；如果等待超时，\n     * 将抛出异常）\n     *\n     * @param timeout 超时时间\n     * @param unit 时间单位\n     * @return 异步执行结果\n     * @throws CancellationException 如果任务执行时被取消，那么抛出该异常\n     * @throws ExecutionException 如果任务代码执行时发生异常，那么抛出该异常，客户端可以\n     *                            通过捕获该异常，该异常中记录了务代码执行时发生的异常\n     * @throws InterruptedException 如果在等待时，当前线程被中断，那么抛出该异常\n     * @throws TimeoutException 如果等待超时，抛出该异常\n     */\n    V get(long timeout, TimeUnit unit)\n            throws InterruptedException, ExecutionException, TimeoutException;\n}\n")])])]),n("p",[e._v("在Future接口的方法定义中，重点理解cancel方法在取消任务时执行的策略。")]),e._v(" "),n("h2",{attrs:{id:"_2-runnablefuture"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-runnablefuture"}},[e._v("#")]),e._v(" 2. RunnableFuture")]),e._v(" "),n("p",[e._v("RunnableFuture接口很简单，只是在继承Future接口的同时继承了Runnable接口，使得其实现类不仅可以保存异步任务的执行状态和结果，同时也可以作为一个任务直接执行。")]),e._v(" "),n("p",[n("strong",[e._v("源码解读")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public interface RunnableFuture<V> extends Runnable, Future<V> {\n    /**\n     * Sets this Future to the result of its computation\n     * unless it has been cancelled.\n     * \n     * 此处的原版注释很好理解，我之所以没放中文翻译是因为翻译过来总\n     * 是很拗口，比如这样：将自身作为自身执行后的future结果...\n     * 看吧，翻译成中文太尴尬了...好在英文注释很简单，大家自行理解吧\n     */\n    void run();\n}\n")])])]),n("h2",{attrs:{id:"_3-futuretask"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-futuretask"}},[e._v("#")]),e._v(" 3. FutureTask")]),e._v(" "),n("p",[e._v("FutureTask是RunnableFuture接口的实现。")]),e._v(" "),n("p",[e._v("关于FutureTask的实现，一定要理解FutureTask的各种状态以及状态间是如何转换的。")]),e._v(" "),n("h3",{attrs:{id:"_3-1-内部字段"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-内部字段"}},[e._v("#")]),e._v(" 3.1 内部字段")]),e._v(" "),n("p",[e._v("对各个字段的详解，都在代码是用注释说明了，要重点理解FutureTask内部定义的几种状态。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/**\n * 任务运行状态，初始化时为NEW.\n * 只有在set、setException和cancel方法中会将运行状态转化为最终\n * 状态（最终状态不是一个固定的状态，而是代表任务进入某个状态后，\n * 任务状态不会再变化了）\n *\n * 在任务完成期间，任务状态可能是COMPLETING（正在设置执行结果），或者\n * INTERRUPTING（调用cancel(true)后强制中断执行任务）。\n *\n * 任务从中间状态过渡到最终状态是通过改变int值实现的，因为每个状态都用\n * 唯一的int值表示，所以任务状态值的改变会很高效\n *\n * 任务状态的转变可能有以下几种情况:\n * NEW -> COMPLETING -> NORMAL\n * NEW -> COMPLETING -> EXCEPTIONAL\n * NEW -> CANCELLED\n * NEW -> INTERRUPTING -> INTERRUPTED\n */\n\n//当前任务状态，注意，该字段用volatile关键字修饰，每次状态的变化对所有线程都是可见的\nprivate volatile int state;\n\n/**\n * 各个状态详解：\n * NEW:表示是个新的任务或者还没被执行完的任务。这是初始状态。\n * COMPLETING:任务已经执行完成或者执行任务的时候发生异常，\n *              但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，\n *              如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态\n *              时间会比较短，属于中间状态。\n * NORMAL:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。\n *             这是一个最终态。\n * EXCEPTIONAL:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到\n *               EXCEPTIONAL。这是一个最终态。\n * CANCELLED:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)\n *              方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。\n * INTERRUPTING: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法\n *                  取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。\n *                  这是一个中间状态。\n * INTERRUPTED:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。\n *                  这是一个最终态。\n */\nprivate static final int NEW          = 0;\nprivate static final int COMPLETING   = 1;\nprivate static final int NORMAL       = 2;\nprivate static final int EXCEPTIONAL  = 3;\nprivate static final int CANCELLED    = 4;\nprivate static final int INTERRUPTING = 5;\nprivate static final int INTERRUPTED  = 6;\n\n/** Callable任务 */\nprivate Callable<V> callable;\n/** 任务执行结果或者异常 */\nprivate Object outcome; // non-volatile, protected by state reads/writes\n/** 执行任务的线程 */\nprivate volatile Thread runner;\n/** 基于无锁并发栈结构的等待线程 */\nprivate volatile WaitNode waiters;\n")])])]),n("h3",{attrs:{id:"_3-2-构造函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-构造函数"}},[e._v("#")]),e._v(" 3.2 构造函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/**\n * 通过Callable任务初始化FutureTask，任务执行成功后，get()方法返回的值为Callable任务\n * 的call方法返回的值。\n */\npublic FutureTask(Callable<V> callable) {\n    if (callable == null)\n        throw new NullPointerException();\n    this.callable = callable;\n    this.state = NEW;       // ensure visibility of callable\n}\n\n/**\n * 通过Runnable任务初始化FutureTask，任务执行成功后，get()方法返回的值为作为构造参数传入\n * 的值result\n */\npublic FutureTask(Runnable runnable, V result) {\n    this.callable = Executors.callable(runnable, result);\n    this.state = NEW;       // ensure visibility of callable\n}\n")])])]),n("p",[e._v("FutureTask提供了两个构造函数，分别通过Callable任务和Runnable任务来初始化一个FutureTask，因为Runnable类型任务是没有返回值的，所以我们需要指定任务执行成功后的返回值。")]),e._v(" "),n("p",[e._v("在FutureTask构造方法中，通过Executors工具类将Runnable任务包装成Callable类型任务，我们可以看下是如何包装的：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public static <T> Callable<T> callable(Runnable task, T result) {\n    if (task == null)\n        throw new NullPointerException();\n//将Runnable 类型任务包装为RunnableAdapter\n    return new RunnableAdapter<T>(task, result);\n}\n\n//RunnableAdapter继承了Callable接口，并在call方法中调用了task的run方法来执行任务，执行完毕后，返回指定的值result\nstatic final class RunnableAdapter<T> implements Callable<T> {\n    final Runnable task;\n    final T result;\n    RunnableAdapter(Runnable task, T result) {\n        this.task = task;\n        this.result = result;\n    }\n    public T call() {\n        task.run();\n        return result;\n    }\n}\n")])])]),n("h3",{attrs:{id:"_8-3-获取任务执行结果"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-获取任务执行结果"}},[e._v("#")]),e._v(" 8.3 获取任务执行结果")]),e._v(" "),n("p",[e._v("通过get方法获取任务执行结果：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/**\n * 获取任务执行结果，如果任务没有执行完毕，那么一直等待任务执行完毕\n */\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        //如果任务出于未完成状态，那么等待任务完成\n        s = awaitDone(false, 0L);\n    //如果任务已经完成，那么返回结果\n    return report(s);\n}\n\n/**\n * 获取任务执行结果，如果任务没有执行完毕，那么等待指定的时间，如果等待超时，任务\n * 仍未完成，那么抛出TimeoutException异常\n */\npublic V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n    if (unit == null)\n        throw new NullPointerException();\n    int s = state;\n    if (s <= COMPLETING &&\n            (s = awaitDone(true, unit.toNanos(timeout))) <= COMPLETING)\n        throw new TimeoutException();\n    return report(s);\n}\n\nprivate int awaitDone(boolean timed, long nanos)\n        throws InterruptedException {\n    //确定任务的执行时间\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    WaitNode q = null;\n    boolean queued = false;\n    for (;;) {\n        if (Thread.interrupted()) {\n            //如果当前线程被中断，那么在等待线程的队列中移除此线程\n            removeWaiter(q);\n            throw new InterruptedException();\n        }\n\n        int s = state;\n        if (s > COMPLETING) {\n            //已经执行完毕（无论成功与否），或者正在被取消，或者已经被取消\n            if (q != null)\n                //不再需要其他线程来等待执行该任务了\n                q.thread = null;\n            //直接返回任务状态\n            return s;\n        }\n        else if (s == COMPLETING)\n            //如果任务处于COMPLETING状态，说明任务执行完毕（可能成功也可能失败），\n            //  但是还未来的及将执行结果赋给outcome变量，那么当前线程要让出优先权\n            Thread.yield();\n        else if (q == null)\n            //如果等待线程队列为空，那么新建等待线程队列节点\n            q = new WaitNode();\n        else if (!queued)\n            //如果还没有入列，那么把当前节点加入waiters首节点并替换原来waiters\n            // 也就是说，将当前线程放到等待线程队列的首位\n            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                    q.next = waiters, q);\n        else if (timed) {\n            //如果需要等待，那么计算等待时间\n            nanos = deadline - System.nanoTime();\n            if (nanos <= 0L) {\n                //如果已经超时，那么删除等待节点并返回任务状态\n                removeWaiter(q);\n                return state;\n            }\n            //否则等待指定时间后执行任务\n            LockSupport.parkNanos(this, nanos);\n        }\n        else\n            //阻塞等待直到被其他线程唤醒\n            LockSupport.park(this);\n    }\n}\n")])])]),n("p",[n("strong",[e._v("具体的执行流程如下：")])]),e._v(" "),n("ul",[n("li",[e._v("计算等待时间deadline，如果是带超时时间的get，deadline = 当前时间 + 等待时间，如果是不带超时时间的get，deadline = 0。")]),e._v(" "),n("li",[e._v("判断线程是否中断，如果线程中断，将当前线程从等待队列waiters中移除，抛出中断异常，否则，跳转到步骤3。")]),e._v(" "),n("li",[e._v("获取task状态state：\n如果task状态为已完成状态，将等待线程节点的线程置为null，返回state；\n如果task状态为正在执行，调用"),n("code",[e._v("Thread.yield()")]),e._v("将线程从执行状态变为可执行状态；\n否则，跳转到步骤4。")]),e._v(" "),n("li",[e._v("如果等待线程节点q为null，初始化等待线程节点q，否则，跳转到步骤5。")]),e._v(" "),n("li",[e._v("如果当前等待线程节点q还未成功进入等待队列waiters，进入线程等待队列，否则，跳转到步骤6。")]),e._v(" "),n("li",[e._v("判断是否是带超时时间的get：\n如果是带超时时间get，判断当前是否超时，如果已经超时，将当前等待节点q从waiters中移出，返回task状态state，如果还未超时，调用LockSupport.parkNanos方法阻塞当前线程；\n否则，跳转到步骤7。")]),e._v(" "),n("li",[e._v("调用LockSupport.park方法，阻塞当前线程，然后跳转到步骤2。")])]),e._v(" "),n("p",[e._v("从get方法整个流程可以看出：\nFutureTask维护一个等待线程队列waiters，如果task还未执行完毕，调用get方法的线程会先进入等待队列自旋等待；\nawaitDone方法其实是个死循环，直到task状态变为已完成状态或者等待时间超过超时时间或者线程中断才会跳出循环，程序结束；\n为了节省开销，线程不会一直自旋等待，而是会阻塞，使用LockSupport的park系列方法实现线程阻塞；")]),e._v(" "),n("h3",{attrs:{id:"_8-4-执行任务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-执行任务"}},[e._v("#")]),e._v(" 8.4 执行任务")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public void run() {\n    //如果任务不是初始状态，说明已经有其他线程在执行任务或者执行完毕，那么直接返回\n    if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                    null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                result = c.call();\n                ran = true;\n            } catch (Throwable ex) {\n                result = null;\n                ran = false;\n                //任务执行失败，将异常赋给outcome字段\n                setException(ex);\n            }\n            if (ran)\n                //任务执行成功，将结果赋给outcome字段\n                set(result);\n        }\n    } finally {\n        //任务执行完毕，无论成功或是失败，都属于执行完毕，那么将任务绑定的线程置为null\n        runner = null;\n        int s = state;\n        if (s >= INTERRUPTING)\n            //如果只想能够任务的线程正在被中断或者已经被中断，那么进行处理\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n\nprivate void handlePossibleCancellationInterrupt(int s) {\n    // 如果执行任务的线程正在被中断，那么当前线程让出优先权，\n    //  来优先执行线程的中断操作\n    if (s == INTERRUPTING)\n        while (state == INTERRUPTING)\n            Thread.yield();\n}\n")])])]),n("h3",{attrs:{id:"_8-5-取消任务"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-5-取消任务"}},[e._v("#")]),e._v(" 8.5 取消任务")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public boolean cancel(boolean mayInterruptIfRunning) {\n    //只有NEW状态的任务才允许直接取消\n    if (!(state == NEW &&\n            UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n                    mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        return false;\n    try {    // in case call to interrupt throws exception\n        if (mayInterruptIfRunning) {\n            try {\n                Thread t = runner;\n                if (t != null)\n                    //如果允许强制中断并且任务正在执行，那么强制中断执行任务的线程\n                    t.interrupt();\n            } finally { // final state\n                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);\n            }\n        }\n    } finally {\n        //任务取消完成后，通过finishCompletion方法唤醒所有等待线程队列中的线程\n        finishCompletion();\n    }\n    return true;\n}\n")])])]),n("h3",{attrs:{id:"_8-6-其他"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_8-6-其他"}},[e._v("#")]),e._v(" 8.6 其他")]),e._v(" "),n("p",[e._v("在FutureTask内部，任务状态的转换以及等待线程队列节点的更新，都是通过cas方式实现的，FutureTask内部使用UNSAFE对象来完成所有的cas操作。")]),e._v(" "),n("p",[e._v("UNSAFE对象可以线程安全地获取内容，但是这并不代表它适合在开发中大量使用。更多时候，UNSAFE出现在成熟的框架中，用于一些底层工作。如果要使用UNSAFE对象，一定要保证代码经过了大量的测试。")]),e._v(" "),n("p",[e._v("UNSAFE对象进行cas操作的api不难理解，从FutureTask的内部示例中，可以很容易理解:")]),e._v(" "),n("p",[e._v("这是FutureTask内部维护的UNSAFE对象")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Unsafe mechanics\nprivate static final sun.misc.Unsafe UNSAFE;\nprivate static final long stateOffset;\nprivate static final long runnerOffset;\nprivate static final long waitersOffset;\nstatic {\n    try {\n        UNSAFE = sun.misc.Unsafe.getUnsafe();\n        Class<?> k = FutureTask.class;\n        stateOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField("state"));\n        runnerOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField("runner"));\n        waitersOffset = UNSAFE.objectFieldOffset\n                (k.getDeclaredField("waiters"));\n    } catch (Exception e) {\n        throw new Error(e);\n    }\n}\n')])])]),n("p",[e._v("这是一段使用UNSAFE对象进行cas更新操作的代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("UNSAFE.compareAndSwapObject(this,runnerOffset,null,Thread.currentThread())\n")])])]),n("p",[n("code",[e._v("compareAndSwapObject")]),e._v("方法的参数1是要修改的对象，参数2是要修改的字段在对象中的偏移量表示（long），参数3是期望的当前值，参数4是要更新的最新值。")]),e._v(" "),n("p",[e._v("其他方法参考api或者查看源码，此处不再讲解关于UNSAFE过多的内容。")]),e._v(" "),n("h2",{attrs:{id:"_4-scheduledfuture"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-scheduledfuture"}},[e._v("#")]),e._v(" 4. ScheduledFuture")]),e._v(" "),n("p",[e._v("首先，看一下ScheduledFuture接口的定义：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public interface ScheduledFuture<V> extends Delayed, Future<V> { \n}\n")])])]),n("p",[e._v("ScheduledFuture接口除了继承Future接口外，还继承了Delayed接口，来看下Delayed接口：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public interface Delayed extends Comparable<Delayed> { \n    long getDelay(TimeUnit unit); \n}\n")])])]),n("p",[e._v("Delayed接口中只定义了一个getDelay方法，用于返回从现在起，多久后开始执行定时任务。这样一来，ScheduledFuture的实现就可以通过实现该方法获取距离任务执行所剩的延时时间。")]),e._v(" "),n("h2",{attrs:{id:"_5-runnablescheduledfuture"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-runnablescheduledfuture"}},[e._v("#")]),e._v(" 5. RunnableScheduledFuture")]),e._v(" "),n("p",[e._v("首先，看一下RunnableScheduledFuture接口的定义：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public interface RunnableScheduledFuture<V> extends RunnableFuture<V>, ScheduledFuture<V> { \n    boolean isPeriodic(); \n}\n")])])]),n("p",[e._v("RunnableScheduledFuture接口继承了ScheduledFuture和RunnableFuture，并且定义了isPeriodic方法，当任务需要周期性重复执行时，该方法返回true.")]),e._v(" "),n("h2",{attrs:{id:"_6-scheduledfuturetask"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-scheduledfuturetask"}},[e._v("#")]),e._v(" 6. ScheduledFutureTask")]),e._v(" "),n("p",[e._v("ScheduledFutureTask作为RunnableScheduledFuture接口的实现，是在ScheduledThreadPoolExecutor线程池中作为私有内部类声明的，因为ScheduledFutureTask只在该线程池中使用，所以可以作为私有内部类声明。")]),e._v(" "),n("h3",{attrs:{id:"_6-1-字段属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-字段属性"}},[e._v("#")]),e._v(" 6.1 字段属性")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/** 任务队列中任务数 */\nprivate final long sequenceNumber;\n\n/** 任务初始执行的延时时长 */\nprivate long time;\n\n/**\n * 任务周期性重复执行时，两次执行之间的延时时长\n */\nprivate final long period;\n\n/** 重新入列的周期性任务 */\nRunnableScheduledFuture<V> outerTask = this;\n\n/**\n * 二叉堆索引\n */\nint heapIndex;\n")])])]),n("h3",{attrs:{id:"_6-2-构造函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-构造函数"}},[e._v("#")]),e._v(" 6.2 构造函数")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/**\n * 创建一次性的延时任务\n */\nScheduledFutureTask(Runnable r, V result, long ns) {\n    super(r, result);\n    //设置延时时间\n    this.time = ns;\n    //不需要周期性重复执行，所以设置周期延时为0\n    this.period = 0;\n    //更新队列中的任务数\n    this.sequenceNumber = sequencer.getAndIncrement();\n}\n\n/**\n * 创建周期任务，延时ns后开始第一次执行任务，此后每隔period时长重复执行任务\n */\nScheduledFutureTask(Runnable r, V result, long ns, long period) {\n    super(r, result);\n    this.time = ns;\n    this.period = period;\n    this.sequenceNumber = sequencer.getAndIncrement();\n}\n\n/**\n * 创建周期任务，延时ns后开始第一次执行任务，此后每隔period时长重复执行任务\n */\nScheduledFutureTask(Callable<V> callable, long ns) {\n    super(callable);\n    this.time = ns;\n    this.period = 0;\n    this.sequenceNumber = sequencer.getAndIncrement();\n}\n")])])]),n("h3",{attrs:{id:"_6-3-getdelay"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-getdelay"}},[e._v("#")]),e._v(" 6.3 getDelay")]),e._v(" "),n("p",[e._v("获取当前时间距离任务执行的延时")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public long getDelay(TimeUnit unit) {\n    return unit.convert(time - now(), NANOSECONDS);\n}\n")])])]),n("h3",{attrs:{id:"_6-4-compareto"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-compareto"}},[e._v("#")]),e._v(" 6.4 compareTo")]),e._v(" "),n("p",[e._v("重点看一下compareTo方法，因为定时任务的排序是按照执行时间排序的，从任务执行时间到当前时间的延时越小，任务越靠前。所以ScheduledFutureTask之间的比较也是通过delay的比较来确定大小")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public int compareTo(Delayed other) {\n    if (other == this) // compare zero if same object\n        return 0;\n    if (other instanceof ScheduledFutureTask) {\n        ScheduledFutureTask<?> x = (ScheduledFutureTask<?>)other;\n        long diff = time - x.time;\n        if (diff < 0)\n            return -1;\n        else if (diff > 0)\n            return 1;\n        else if (sequenceNumber < x.sequenceNumber)\n            return -1;\n        else\n            return 1;\n    }\n    long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);\n    return (diff < 0) ? -1 : (diff > 0) ? 1 : 0;\n}\n")])])]),n("h3",{attrs:{id:"_6-5-run"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-run"}},[e._v("#")]),e._v(" 6.5 run")]),e._v(" "),n("p",[e._v("执行任务")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public void run() {\n    //首先，通过isPeriodic方法判断当前任务是否是周期任务\n    boolean periodic = isPeriodic();\n    if (!canRunInCurrentRunState(periodic))\n        //如果当前线程池运行状态下不允许执行任务，取消该任务\n        cancel(false);\n    else if (!periodic)\n        //如果是非周期性任务，那么调用父类FutureTask方法，只执行一次\n        ScheduledFutureTask.super.run();\n    else if (ScheduledFutureTask.super.runAndReset()) {\n        //如果是周期性任务，调用run方法执行任务，执行完毕后重新初始化任务状态，\n        // 为下一次执行做准备\n        \n        //设置任务下一次执行的延时\n        setNextRunTime();\n        //重新将任务入列，等待下次执行\n        reExecutePeriodic(outerTask);\n    }\n}\n")])])]),n("h3",{attrs:{id:"_6-6-cancel"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-cancel"}},[e._v("#")]),e._v(" 6.6 cancel")]),e._v(" "),n("p",[e._v("取消任务")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public boolean cancel(boolean mayInterruptIfRunning) {\n    //调用父类FutureTask的cancel方法取消任务\n    boolean cancelled = super.cancel(mayInterruptIfRunning);\n    if (cancelled && removeOnCancel && heapIndex >= 0)\n        //如果取消成功，并且ScheduledThreadPoolExecutor线程池设置任务取消后删除任务，\n        //  并且任务队列不为空，那么删除被取消的任务\n        remove(this);\n    return cancelled;\n}\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);