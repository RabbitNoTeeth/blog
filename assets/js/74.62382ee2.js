(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{358:function(n,e,t){"use strict";t.r(e);var a=t(7),l=Object(a.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[e("strong",[n._v("考虑下面的一个单例模式:")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//代码清单1\npublic class Singleton implements Serializable{\n    \n    private static final Singleton INSTANCE = new Singleton();\n    \n    private Singleton(){}\n\n    public static Singleton getInstance() {\n        return INSTANCE;\n    }\n}\n")])])]),e("p",[n._v("如果Singleton类实现了Serializable接口，那么就不再能保证是单例的。因为攻击者可以通过反序列化创建新的实例，在上一章节就讲到readObject方法就相当于一个公有的构造器。")]),n._v(" "),e("p",[e("strong",[n._v("可以通过readResolve方法来控制readObject创建的实例，修复上面的bug：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//代码清单2\npublic class Singleton implements Serializable {\n\n    //如果依赖readResolve进行实例控制,那么带有对象引用的所有实例域都要声明为transient的\n    private static final transient Singleton INSTANCE = new Singleton();\n\n    private Singleton(){}\n\n    public static Singleton getInstance() {\n        return INSTANCE;\n    }\n\n    private Object readResolve(){\n        return INSTANCE;\n    }\n}\n")])])]),e("p",[n._v("对于一个正在被反序列化的对象，如果它的类定义了一个readResolve方法，并且具有正确的声明，那么在反序列化之后，新建对象上的readResolve方法就会被调用，然后该方法返回的对象将取代新创建的对象被返回。")]),n._v(" "),e("p",[e("strong",[n._v("还有一个更加简单的方法来修复代码清单1中的bug，那就是之前介绍过的声明为单元素枚举类型：")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("//代码清单3\npublic enum Singleton2 implements Serializable {\n    INSTANCE\n}\n")])])]),e("p",[n._v("可以看到，使用单元素枚举来声明单例类，非常简单和安全，但是在java中的使用度却并不高。在Kotlin中，一个被object关键字修饰的类表示一个单例类，其实现原理就是编译器将该类声明为一个单元素枚举类。")])])}),[],!1,null,null,null);e.default=l.exports}}]);