(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{348:function(n,t,i){"use strict";i.r(t);var o=i(7),s=Object(o.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("许多枚举天生就与一个单独的int值相关联，所有的枚举都有一个ordinal方法，它返回每个枚举常量在类型中的数字位置。")]),n._v(" "),t("p",[t("strong",[n._v("代码示例：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('enum  Operation {\n\n    PLUS, MINUS, TIMES , DIVIDE;\n\n    public int position(){\n        return this.ordinal() + 1;\n    }\n\n}\n\nclass Test{\n    public static void main(String[] args) {\n        for(Operation op:Operation.values()){\n            System.out.println(op + ", position = " + op.position());\n        }\n    }\n}\n\nPLUS, position = 1\nMINUS, position = 2\nTIMES, position = 3\nDIVIDE, position = 4\n')])])]),t("p",[n._v("在示例中，position方法依赖于ordinal方法的返回值，如果枚举常量进行了重新排序，那么ordinal将会返回不同的值，此时position方法就会遭到破坏。")]),n._v(" "),t("p",[t("strong",[n._v("如何解决?")])]),n._v(" "),t("p",[n._v("永远不要根据枚举的序数导出与它相关联的值，而是要将它们保存在一个实例域中。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("enum  Operation {\n\n    PLUS(1), MINUS(2), TIMES(3), DIVIDE(4);\n\n    private final int position;\n    Operation(int position) {\n        this.position = position;\n    }\n    public int position(){\n        return this.position;\n    }\n\n}\n")])])]),t("p",[n._v("这样，position方法便不在依赖ordinal的返回值，而是返回实例域的值，无论枚举常量怎样排序，position始终返回不变的值。")]),n._v(" "),t("p",[t("strong",[n._v("尽量避免使用ordinal方法。")])])])}),[],!1,null,null,null);t.default=s.exports}}]);