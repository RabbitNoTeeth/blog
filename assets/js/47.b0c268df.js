(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{332:function(a,t,n){"use strict";n.r(t);var e=n(7),r=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("一般来说，最好能重用对象而不是每次需要的时候都创建新的对象。如果对象是不可变的，那么它就始终可以被重用。")]),a._v(" "),t("h2",{attrs:{id:"_1-反面示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-反面示例"}},[a._v("#")]),a._v(" 1. 反面示例")]),a._v(" "),t("p",[a._v("一个极端的反面例子:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('String s = new String("liuxindong");\n')])])]),t("p",[a._v("该语句每次执行都会创建一个新的String实例。")]),a._v(" "),t("p",[a._v("改进后:")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('String s = "liuxindong";\n')])])]),t("p",[a._v("改进后只用了一个String实例，对于同一台虚拟机上运行的代码，只要它们包含相同的字符串字面常量，该对象就会被重用。")]),a._v(" "),t("h2",{attrs:{id:"_2-避免创建不必要对象的常见做法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-避免创建不必要对象的常见做法"}},[a._v("#")]),a._v(" 2. 避免创建不必要对象的常见做法")]),a._v(" "),t("h3",{attrs:{id:"_2-1-使用静态工厂"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-使用静态工厂"}},[a._v("#")]),a._v(" 2.1 使用静态工厂")]),a._v(" "),t("p",[a._v("通常可以使用静态工厂来避免创建不必要的对象。")]),a._v(" "),t("h3",{attrs:{id:"_2-2-重用已知不会被修改的可变对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-重用已知不会被修改的可变对象"}},[a._v("#")]),a._v(" 2.2 重用已知不会被修改的可变对象")]),a._v(" "),t("p",[a._v("除了重用不可变得对象外,也可以重用已知不会被修改的可变对象 。")]),a._v(" "),t("p",[a._v("一个效率低下的代码示例：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("public class Person {\n    \n    private final Date birthday;\n\n    public Person(Date birthday) {\n        this.birthday = birthday;\n    }\n    \n    public boolean isBabyBoomer(){\n        Calendar calendar = Calendar.getInstance();\n        calendar.set(1990,Calendar.JANUARY,1);\n        Date start = calendar.getTime();\n        calendar.set(1999,Calendar.DECEMBER,1);\n        Date end = calendar.getTime();\n        return birthday.compareTo(start)>=0 && birthday.compareTo(end)<0;\n    }\n}\n")])])]),t("p",[a._v("方法isBabyBoomer()在每次调用时都会创建Calendar实例，这其实是不必要的。")]),a._v(" "),t("p",[a._v("改进后：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("public class Person {\n\n    private final Date birthday;\n\n    private static final Date start;\n\n    private static final Date end;\n    \n    static {\n        Calendar calendar = Calendar.getInstance();\n        calendar.set(1990,Calendar.JANUARY,1);\n        start = calendar.getTime();\n        calendar.set(1999,Calendar.DECEMBER,1);\n        end = calendar.getTime();\n    }\n\n    public Person(Date birthday) {\n        this.birthday = birthday;\n    }\n\n    public boolean isBabyBoomer(){\n        return birthday.compareTo(start)>=0 && birthday.compareTo(end)<0;\n    }\n}\n")])])]),t("p",[a._v("改进后，Calendar只在Person初始化时创建一次。如果isBabyBoomer被频繁地调用，能显著的提高性能。")]),a._v(" "),t("h3",{attrs:{id:"_2-3-优先使用基本数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-优先使用基本数据类型"}},[a._v("#")]),a._v(" 2.3  优先使用基本数据类型")]),a._v(" "),t("p",[a._v("优先使用基本数据类型而不是装箱基本类型，当心无意识的自动装箱。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("public static void main(String[] args) {\n    Long sum = 0L;\n    for(long i=0;i<Integer.MAX_VALUE;i++){\n        sum += i;\n    }\n    System.out.println(sum);\n}\n")])])]),t("p",[a._v("这段程序虽然运行是没有错误的，但是因为将sum声明成了Long而不是long，导致每次调用循环体中的代码时，都会创建多余的Long实例，所以其运行速度会更慢。")]),a._v(" "),t("h3",{attrs:{id:"_2-4-谨慎使用对象池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-谨慎使用对象池"}},[a._v("#")]),a._v(" 2.4 谨慎使用对象池")]),a._v(" "),t("p",[a._v("不要错误的认为所有对象创建的代价都是昂贵的，实际上，小对象的创建和回收是非常廉价的，尤其是在越来越优化的JVM上，通过创建附加的对象来提升程序的简洁性和功能性，通常是件好事。")]),a._v(" "),t("p",[a._v("反之，通过维护自己的对象池来避免创建对象并不总是一件好事。对象池的应用，应该用在对象的创建很昂贵的情况下，典型的有数据库连接对象的创建。对于一般的对象而言，现代的JVM具有高度优化的垃圾回收器，其性能很容易就会超过轻量级对象池的性能。")])])}),[],!1,null,null,null);t.default=r.exports}}]);