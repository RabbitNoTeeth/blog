(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{343:function(t,a,n){"use strict";n.r(a);var i=n(7),s=Object(i.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-尽可能地使每个类或者成员不被外界访问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-尽可能地使每个类或者成员不被外界访问"}},[t._v("#")]),t._v(" 1. 尽可能地使每个类或者成员不被外界访问")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("对于顶层的(非嵌套的)类和接口，只有两种可能的访问级别：包级私有(package private)或者公有(public)。建议只将作为API导出的类或者接口声明为public公有，其他的做成包级私有的，因为这样可以在以后的版本更新中，对包级私有的类或者接口进行修改、替换或者删除时，不用考虑对客户端带来的影响，因为客户端访问不到他们。一旦将类或者接口声明为public，就要永久负责对它的支持和保持它的兼容性，因为如果做不到，会给客户端带来严重的后果。")])]),t._v(" "),a("li",[a("p",[t._v("如果一个包级私有的顶层类(或者接口)只在一个类的内部被用到，那么就用该考虑使它成为那个类的私有嵌套类。")])]),t._v(" "),a("li",[a("p",[t._v("对于公有类的成员，当访问级别从包级私有变成protected保护级别时，会大大增加可访问性。受保护的成员是类的导出API的一部分，必须得到永久的支持。导出类的受保护成员也代表了该类对某个实现细节的公开承诺。受保护的成员应该尽量少用。")])])]),t._v(" "),a("h2",{attrs:{id:"_2-实例域决不能是公有的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-实例域决不能是公有的"}},[t._v("#")]),t._v(" 2. 实例域决不能是公有的")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("如果域是非final的，或者是一个指向可变对象的final引用，那么一旦这个域成为公有的，就放弃了对存储在这个域中的值进行限制的能力，这意味着放弃了强制这个域不可变的能力。同时，当这个域被修改时，也失去了对它采取任何行动的能力。因此，包含公有可变域的类并不是线程安全的，即使域是final的，并且引用不可变对象。")])]),t._v(" "),a("li",[a("p",[t._v("同样的建议也适用于静态域。只有一种例外情况，假设常量构成了类提供的整个抽象中的一部分，那么可以通过公有的静态final域来暴露这些常量。")])]),t._v(" "),a("li",[a("p",[t._v("注意，长度非零的数组总是可变的，所以，类具有公有的静态final数组域，或者返回这种域的访问方法，这几乎总是错误的。这也是安全漏洞的一个常见根源。")])])]),t._v(" "),a("p",[t._v("错误代码示例:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public static final String[] VALURS = {...};\n")])])]),a("p",[t._v("修正这个问题有两种办法:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//方法一:将数组声明为私有,并提供一个公有不可变的列表\nprivate static final String[] PRIVATE_VALURS = {};\n\npublic static final List<String> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALURS));\n\n//方法二:将数组声明为私有,并提供一个公有方法,返回私有数组的一个备份\nprivate static final String[] PRIVATE_VALURS = {};\n\npublic static final String[] values(){\n    return PRIVATE_VALURS.clone();\n}\n")])])]),a("h2",{attrs:{id:"_3-在公有类中使用访问方法而非公有域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-在公有类中使用访问方法而非公有域"}},[t._v("#")]),t._v(" 3. 在公有类中使用访问方法而非公有域")]),t._v(" "),a("p",[t._v("错误代码示例:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public class Point {\n    \n    public int x;\n    public int y;\n            \n}\n")])])]),a("p",[t._v("修正后:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("public class Point {\n\n    private int x;\n    private int y;\n\n    public int getX() {\n        return x;\n    }\n\n    public void setX(int x) {\n        this.x = x;\n    }\n\n    public int getY() {\n        return y;\n    }\n\n    public void setY(int y) {\n        this.y = y;\n    }\n}\n")])])]),a("ul",[a("li",[a("p",[t._v("如果类可以在它所在的包的外部进行访问，就提供访问方法。")])]),t._v(" "),a("li",[a("p",[t._v("如果类是包级私有的，或者是私有的嵌套类，允许直接暴露它的数据域。")])]),t._v(" "),a("li",[a("p",[t._v("公有域永远都不应该暴露可变的域，而是通过提供访问器或者设置器来实现。")])])]),t._v(" "),a("br"),t._v(" "),a("p",[a("strong",[t._v("小结")])]),t._v(" "),a("p",[t._v("尽可能地降低可访问性。在仔细地设计了一个最小的公有API之后，应该防止把散乱的类、接口或者成员变成API的一部分。除了公有静态final域的特殊情形之外，公有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都是不可变的。")])])}),[],!1,null,null,null);a.default=s.exports}}]);