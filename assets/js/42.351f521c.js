(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{328:function(e,r,n){"use strict";n.r(r);var t=n(7),i=Object(t.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("对于类而言，为了让客户端获取它的一个实例，最常用的方法就是提供一个公有的构造器，还有一种方法就是提供一个静态工厂方法，它是一个返回类的实例的静态方法。 (本章节的静态工厂方法并不直接对应设计模式中的工厂方法)")]),e._v(" "),r("h2",{attrs:{id:"_1-优点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-优点"}},[e._v("#")]),e._v(" 1. 优点")]),e._v(" "),r("ol",[r("li",[r("p",[r("strong",[e._v("它们有名称。")])]),e._v(" "),r("p",[e._v("当一个类需要多个带有相同签名的构造器时，就用静态方法代替构造器，并且慎重地选择名称以便突出它们之间的区别。")])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("不必在每次调用时创建新的对象。")])])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("它们可以返回原返回类型的任何子类型的对象，提供更大的灵活性。")])]),e._v(" "),r("p",[e._v("静态方法返回的对象所属的类，在编写静态方法时可以不必存在，这种灵活的静态工厂方法构成了服务提供者框架的基础。")])])]),e._v(" "),r("h2",{attrs:{id:"_2-服务提供者框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务提供者框架"}},[e._v("#")]),e._v(" 2. 服务提供者框架")]),e._v(" "),r("p",[e._v("服务提供者框架有3个重要的组件：")]),e._v(" "),r("ol",[r("li",[r("p",[r("strong",[e._v("服务接口")]),e._v("。")]),e._v(" "),r("p",[e._v("这是提供者实现的。")])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("提供者注册API")]),e._v("。")]),e._v(" "),r("p",[e._v("这是系统用来注册实现，让客户端访问它们的。")])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("服务访问API")]),e._v("。")]),e._v(" "),r("p",[e._v("是客户端用来获取服务的实例的。服务访问API一般允许但是不要求客户端指定某种选择提供者的条件。如果没有这样的规定，API就会返回默认实现的一个实例。服务访问API是”灵活的静态工厂“，它构成了服务提供者框架的基础。")])])]),e._v(" "),r("p",[e._v("一个简单的服务提供者框架实现:")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('public interface Service {\n    //服务接口\n}\n\npublic interface Provider {\n    //服务提供者接口\n    Service newService();\n}\n\npublic class Services {\n\n    private Services(){}\n\n    private static final Map<String,Provider> providers = new ConcurrentHashMap<>();\n\n    public static final String DEFAULT_PROVIDER_NAME = "<def>";\n\n    //服务提供者注册API\n    public static void registerDefaultProvider(Provider provider){\n        registerProvider(DEFAULT_PROVIDER_NAME,provider);\n    }\n\n    public static void registerProvider(String name,Provider provider){\n        providers.put(name,provider);\n    }\n\n    //服务访问API\n    public static Service newService(){\n        return newInstance(DEFAULT_PROVIDER_NAME);\n    }\n\n    public static Service newInstance(String name) {\n        Provider provider = providers.get(name);\n        if(provider==null){\n            throw new IllegalArgumentException("No provider registered with name:"+name);\n        }\n        return provider.newService();\n    }\n\n}\n')])])]),r("h2",{attrs:{id:"_3-缺点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-缺点"}},[e._v("#")]),e._v(" 3. 缺点")]),e._v(" "),r("ol",[r("li",[r("p",[e._v("类如果不含公有的或者受保护的构造器，就不能被子类化。")])]),e._v(" "),r("li",[r("p",[e._v("它们与其他的静态方法实际上并没有区别，如果在API文档中不加以说明，会使得调用者较难使用.。为了一定程度上弥补该不足，静态工厂方法通常有一些惯用名称: valueOf 、of 、getInstance 、newInstance、getType、newType等")])])]),e._v(" "),r("p",[e._v("静态工厂方法和公有构造器各有用处，要理解它们各自的长处，但是通常情况下，会优先考虑静态工厂方法。")])])}),[],!1,null,null,null);r.default=i.exports}}]);