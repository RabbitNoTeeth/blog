(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{348:function(n,t,e){"use strict";e.r(t);var a=e(7),r=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("枚举类型是指由一组固定的常量组成合法值的类型。通过int枚举模式、String枚举模式和enum的对比，来了解enum的优势。")]),n._v(" "),t("h2",{attrs:{id:"_1-int枚举模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-int枚举模式"}},[n._v("#")]),n._v(" 1. int枚举模式")]),n._v(" "),t("p",[t("strong",[n._v("代码示例")])]),n._v(" "),t("p",[n._v("使用不同的int常量来表示Apple类的各种状态")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("public class Apple {\n    public static final int NAVEL = 0;\n    public static final int TEMPLE = 1;\n    public static final int BLOOD = 2;\n}\n")])])]),t("p",[t("strong",[n._v("缺点")])]),n._v(" "),t("ol",[t("li",[n._v("int枚举是编译时常量，被编译到使用它们的客户端中。如果与之相关联的int值发生了变化，就需要重新编译客户端。")]),n._v(" "),t("li",[n._v("如果有其他方法的参数需要传入Apple的状态时，那么参数类型只能是int，此时就无法保证不会错误的传入4、5、6等其他非法值。")])]),n._v(" "),t("h2",{attrs:{id:"_2-string枚举模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-string枚举模式"}},[n._v("#")]),n._v(" 2. String枚举模式")]),n._v(" "),t("p",[t("strong",[n._v("代码示例")])]),n._v(" "),t("p",[n._v("使用不同的String常量来表示Apple的状态")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('public class Apple {\n    public static final String COLOR_GREEN = "green";\n    public static final String COLOR_RED = "red";\n}\n')])])]),t("p",[t("strong",[n._v("缺点")])]),n._v(" "),t("ol",[t("li",[n._v("可能会导致性能问题，因为它依赖于字符串的比较操作。")]),n._v(" "),t("li",[n._v("String常量的值会被硬编码到客户端代码中，如果存在书写错误，那么在编译时检测不到，运行时出现错误。")]),n._v(" "),t("li",[n._v("如果有其他方法的参数需要传入Apple的状态时，那么参数类型只能是String，此时就无法保证不会错误的传入其他非法字符串。")])]),n._v(" "),t("h2",{attrs:{id:"_3-enum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-enum"}},[n._v("#")]),n._v(" 3. enum")]),n._v(" "),t("p",[t("strong",[n._v("代码示例")])]),n._v(" "),t("p",[n._v("使用enum来优化上面两个示例")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("enum  Apple {\n    NAVEL,TEMPLE,BLOOD\n}\n\nenum  AppleColor {\n    GREEN,RED\n}\n")])])]),t("p",[t("strong",[n._v("优点")])]),n._v(" "),t("ol",[t("li",[n._v("java的枚举本质上是int值，并不会造成额外的开销。")]),n._v(" "),t("li",[n._v("枚举类型是真正的final。")]),n._v(" "),t("li",[n._v("提供了编译时的类型安全，当方法需要Apple的状态最为参数时，那么参数类型就可以明确的指定为Apple，如果传入Apple内枚举常量之外的非法值，就会导致编译错误。")]),n._v(" "),t("li",[n._v("常量值并没有被编译到客户端代码中，而是在int枚举模式之中。所以可以增加或者重新排列枚举类型中的常量，而无需重新编译它的客户端代码。")]),n._v(" "),t("li",[n._v("允许添加任意的方法和域，并实现任意的接口。")])]),n._v(" "),t("p",[t("strong",[n._v("缺点")])]),n._v(" "),t("p",[n._v("与int枚举模式相比，装载和初始化枚举时会有空间和时间的成本。")]),n._v(" "),t("h2",{attrs:{id:"_4-代码示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-代码示例"}},[n._v("#")]),n._v(" 4. 代码示例")]),n._v(" "),t("p",[n._v("一个带有构造器和字段属性的枚举类Fruit，该枚举类的枚举常量有专门的构造方法，并且提供了方法来获取其常量的属性。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('enum  Fruit {\n    \n    APPLE("red",50),\n    ORANGE("orange",20);\n    \n    private final String color;\n    private final int count;\n    Fruit(String color,int count){\n        this.color = color;\n        this.count = count;\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n')])])]),t("h2",{attrs:{id:"_5-使用enum枚举时的建议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-使用enum枚举时的建议"}},[n._v("#")]),n._v(" 5. 使用enum枚举时的建议")]),n._v(" "),t("ol",[t("li",[n._v("枚举天生是不可变的，因此所有的域都应该是final的，它们可以是公有的，但是最好将它们做成私有的，并提供公有的访问方法。")]),n._v(" "),t("li",[n._v("与枚举常量有关联的有些行为，可能只需要用在定义了枚举的类或者包中，那么这些行为最好定义为私有的或者包级私有的。")]),n._v(" "),t("li",[n._v("如果一个枚举类具有普遍适用性，它就应该成为一个顶层类。如果它只是被用在一个顶层类中，那么它就应该作为顶层类的成员类。")]),n._v(" "),t("li",[n._v("枚举类型的toString方法默认返回枚举常量的名称，枚举类型有一个自动生成的方法valueOf(String)，可以将常量的名称转变为常量本身返回。如果在枚举类型中覆盖toString方法，那么考虑编写一个fromString方法，将指定的字符串变回相应的枚举。")])]),n._v(" "),t("h2",{attrs:{id:"_6-扩展-特定于常量的方法实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-扩展-特定于常量的方法实现"}},[n._v("#")]),n._v(" 6. 扩展: 特定于常量的方法实现")]),n._v(" "),t("p",[n._v("如果我们定义了一个enum来表示计算器的四大基本运算")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('enum  Operation {\n\n    PLUS,MINUS,TIMES,DIVIDE;\n    \n    double apply(double x,double y){\n        switch (this){\n            case PLUS: return x+y;\n            case MINUS: return x-y;\n            case TIMES: return x*y;\n            case DIVIDE: return x/y;\n        }\n        throw new AssertionError("Unknown operation");\n    }\n}\n')])])]),t("p",[n._v("如果我们需要对上述枚举类型进行扩展，新增取模和平方等运算，那么在新增枚举变量的同时，还要在switch语句中新增更多条件，如果忘记在switch中新增，那么程序运行就会出错。")]),n._v(" "),t("p",[n._v("enum的特定于常量的方法实现为我们解决了上面的问题，可以在编译时期就检查在增加枚举常量的同时是否实现了apply的操作。如果新增了平方运算常量，但没有实现apply方法时，编译就会报错。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("enum  Operation {\n\n    PLUS {\n        @Override\n        double apply(double x, double y) {\n            return x+y;\n        }\n    },\n    MINUS {\n        @Override\n        double apply(double x, double y) {\n            return x-y;\n        }\n    },\n    TIMES {\n        @Override\n        double apply(double x, double y) {\n            return x*y;\n        }\n    },\n    DIVIDE {\n        @Override\n        double apply(double x, double y) {\n            return x/y;\n        }\n    };\n\n    abstract double apply(double x,double y);\n}\n")])])]),t("p",[t("strong",[n._v("缺点")])]),n._v(" "),t("p",[n._v("不利于代码重用，每个常量类型都需要实现apply方法，当维护的常量很多时，代码会很冗长，同时可能存在大量的样板代码。")])])}),[],!1,null,null,null);t.default=r.exports}}]);