(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{391:function(a,e,t){"use strict";t.r(e);var r=t(7),n=Object(r.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"_1-理解gc日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-理解gc日志"}},[a._v("#")]),a._v(" 1. 理解GC日志")]),a._v(" "),e("p",[a._v("HotSpot VM可以将每次GC的数据直接输出成日志，可以以文本方式查看GC统计数据，或者用GUI监控工具查看。")]),a._v(" "),e("h3",{attrs:{id:"_1-1-重要的垃圾收集数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-重要的垃圾收集数据"}},[a._v("#")]),a._v(" 1.1 重要的垃圾收集数据")]),a._v(" "),e("ol",[e("li",[a._v("当前使用的垃圾收集器。")]),a._v(" "),e("li",[a._v("Java堆的大小。")]),a._v(" "),e("li",[a._v("新生代和老年代的大小。")]),a._v(" "),e("li",[a._v("永久代的大小。")]),a._v(" "),e("li",[a._v("MinorGC的持续时间。")]),a._v(" "),e("li",[a._v("MinorGC的频率。")]),a._v(" "),e("li",[a._v("MinorGC的空间回收量。")]),a._v(" "),e("li",[a._v("FullGC的持续时间。")]),a._v(" "),e("li",[a._v("FullGC的频率。")]),a._v(" "),e("li",[a._v("每个并发垃圾收集周期内的空间回收量。")]),a._v(" "),e("li",[a._v("垃圾收集前后java堆的占用量。")]),a._v(" "),e("li",[a._v("垃圾收集前后新生代和老年代的占用量。")]),a._v(" "),e("li",[a._v("垃圾收集前后永久代的占用量。")]),a._v(" "),e("li",[a._v("是否老年代或者永久代的占用触发了FullGC。")]),a._v(" "),e("li",[a._v("应用是否显式调用了System.gc()。")])]),a._v(" "),e("h3",{attrs:{id:"_1-2-开启gc日志输出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-开启gc日志输出"}},[a._v("#")]),a._v(" 1.2 开启GC日志输出")]),a._v(" "),e("ul",[e("li",[a._v("开启 "),e("code",[a._v("–XX:+PrintGCDetails")]),a._v(" 可以打印出GC日志，默认是打印在console控制台。")]),a._v(" "),e("li",[a._v("使用 "),e("code",[a._v("–Xloggc:filename")]),a._v(" 可以将GC日志直接输出到文件，filename为目标文件名称。")]),a._v(" "),e("li",[a._v("使用 "),e("code",[a._v("–XX:+PrintGCTimeStamps")]),a._v(" 可以在GC日志中输出自jvm启动依赖到垃圾收集之间流逝的秒数，可以通过这个时间戳来统计GC频率。")]),a._v(" "),e("li",[a._v("使用 "),e("code",[a._v("–XX:+PrintGCDateStamps")]),a._v(" 可以在GC日志中输出标准格式的年月日时分秒形式的时间戳，也可以根据此时间戳来统计GC频率。")])]),a._v(" "),e("h3",{attrs:{id:"_1-3-minorgc日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-minorgc日志"}},[a._v("#")]),a._v(" 1.3 MinorGC日志")]),a._v(" "),e("p",[a._v("为了便于注释说明，将日志作了分行处理 。")]),a._v(" "),e("p",[e("strong",[a._v("原始日志")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1:\t76.282: \n2: \t[GC (Allocation Failure) \n3:\t\t[PSYoungGen: 554568K->35404K(573440K)] \n4:\t\t610676K->93743K(641024K), 0.0260886 secs] \n5:\t\t[Times: user=0.06 sys=0.01, real=0.03 secs]\n")])])]),e("p",[e("strong",[a._v("日志说明")])]),a._v(" "),e("ul",[e("li",[e("p",[a._v("第1行")]),a._v(" "),e("p",[a._v("开启了–XX:+PrintGCTimeStamps后的时间戳。")])]),a._v(" "),e("li",[e("p",[a._v("第2行")]),a._v(" "),e("p",[e("code",[a._v("GC")]),a._v("表示是MinorGC。")])]),a._v(" "),e("li",[e("p",[a._v("第3行")]),a._v(" "),e("p",[e("code",[a._v("PSYoungGen")]),a._v("表示新生代使用的是Parallel Scavenge收集器。(如果是"),e("code",[a._v("ParNew")]),a._v("，表示使用的是Parallel收集器； 如果是"),e("code",[a._v("DefNew")]),a._v("，表示使用的是Serial收集器)\n“->”左侧"),e("code",[a._v("554568K")]),a._v("是垃圾收集前新生代的占用量，右侧"),e("code",[a._v("35404K")]),a._v("是垃圾收集后新生代的占用量，因为MinorGC后Eden为空，所以"),e("code",[a._v("35404K")]),a._v("也代表GC后被占用的那一块Survivor的占用量。\n括号中的"),e("code",[a._v("573440K")]),a._v("是Eden和一块被占用的Survivor的和。")])]),a._v(" "),e("li",[e("p",[a._v("第4行")]),a._v(" "),e("p",[a._v("“->”左侧"),e("code",[a._v("610676K")]),a._v("是垃圾收集前java堆的占用量，右侧"),e("code",[a._v("93743K")]),a._v("是垃圾收集后java堆的占用量。\n括号中的"),e("code",[a._v("641024K")]),a._v("是java堆的总量。\n"),e("code",[a._v("0.0260886 secs")]),a._v("是执行垃圾回收花费的时间。")])]),a._v(" "),e("li",[e("p",[a._v("第5行")]),a._v(" "),e("p",[e("code",[a._v("user")]),a._v("是垃圾收集执行非操作系统调用指令所耗费的cpu时间。\n"),e("code",[a._v("sys")]),a._v("是垃圾收集执行操作系统调用指令所耗费的cpu时间。\n"),e("code",[a._v("real")]),a._v("是垃圾收集的实际时间。")])])]),a._v(" "),e("h3",{attrs:{id:"_1-4-fullgc日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-fullgc日志"}},[a._v("#")]),a._v(" 1.4 FullGC日志")]),a._v(" "),e("p",[a._v("为了便于注释说明，将日志作了分行处理。")]),a._v(" "),e("p",[e("strong",[a._v("原始日志:")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1:\t2784.826: \n2:\t\t[Full GC (System.gc()) \n3:\t\t\t[PSYoungGen: 672K->0K(558080K)] \n4:\t\t\t[ParOldGen: 44257K->38446K(90112K)] \n5:\t\t\t44929K->38446K(648192K), \n6:\t\t\t[Metaspace: 61626K->61360K(1103872K)], 0.2257245 secs] \n7:\t\t\t[Times: user=0.84 sys=0.00, real=0.23 secs]\n")])])]),e("p",[e("strong",[a._v("日志说明")])]),a._v(" "),e("ul",[e("li",[e("p",[a._v("第1行")]),a._v(" "),e("p",[a._v("开启了–XX:+PrintGCTimeStamps后的时间戳。")])]),a._v(" "),e("li",[e("p",[a._v("第2行")]),a._v(" "),e("p",[e("code",[a._v("Full GC")]),a._v(",直接标明了GC类型"),e("code",[a._v("(System.gc())")]),a._v(" 表示是通过程序中显式调用System.gc()触发的FullGC，如果是由jvm自动触发，则没有此参数。")])]),a._v(" "),e("li",[e("p",[a._v("第3行")]),a._v(" "),e("p",[a._v("和上面MinorGC中的含义相同，不再赘述。")])]),a._v(" "),e("li",[e("p",[a._v("第4行")]),a._v(" "),e("p",[e("code",[a._v("ParOldGen")]),a._v("说明老年代使用了Parallel Old收集器。\n“->”左侧"),e("code",[a._v("44257K")]),a._v("是垃圾回收前老年代的使用量，右侧38446K是垃圾收集后老年代的使用量。\n括号中的"),e("code",[a._v("90112K")]),a._v("是老年代的大小。")])]),a._v(" "),e("li",[e("p",[a._v("第5行")]),a._v(" "),e("p",[e("code",[a._v("44929K->38446K(648192K)")]),a._v("是java堆的使用情况，同MinorGC中含义相同，不在赘述。")])]),a._v(" "),e("li",[e("p",[a._v("第6行")])]),a._v(" "),e("li",[e("p",[e("code",[a._v("Metaspace")]),a._v("表示元数据区，此日志是java8的jvm生成，因为java8中HotSpot删除了永久代，取而代之的是元数据区。\n“->”左侧的"),e("code",[a._v("61626K")]),a._v("是垃圾收集前元数据区的使用量，右侧的"),e("code",[a._v("61360K")]),a._v("是垃圾收集后元数据区的使用量。\n括号中的"),e("code",[a._v("1103872K")]),a._v("是元数据区大小。\n"),e("code",[a._v("0.2257245 secs")]),a._v("是此次FullGC花费的时间。")])]),a._v(" "),e("li",[e("p",[a._v("第7行")]),a._v(" "),e("p",[a._v("含义和MinorGC中相同，不再赘述。")])])]),a._v(" "),e("p",[a._v("FullGC中值得关注的是垃圾收集之前老年代和元数据区的占用量，因为当两者的占用接近其容量时，都会触发FullFC。")]),a._v(" "),e("h3",{attrs:{id:"_1-5-cms老年代gc日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-cms老年代gc日志"}},[a._v("#")]),a._v(" 1.5 CMS老年代GC日志")]),a._v(" "),e("p",[a._v("当 "),e("code",[a._v("–XX:+UseConcMarkSweepGC")]),a._v(" 使用CMS收集器时，会自动开启 "),e("code",[a._v("–XX:+UserParNewGC")]),a._v("。CMS在老年代的GC日志与上面的FullGC日志有很大的不同.")]),a._v(" "),e("p",[e("strong",[a._v("原始日志:")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("1:\t7.879: [GC (CMS Initial Mark) [1 CMS-initial-mark: 37262K(87424K)] 42307K(126720K), 0.0009025 secs] \n                [Times: user=0.00 sys=0.00, real=0.00 secs] \n2:\t7.880: [CMS-concurrent-mark-start]\n3:\t7.905: [CMS-concurrent-mark: 0.023/0.025 secs] [Times: user=0.06 sys=0.00, real=0.02 secs] \n4:\t7.905: [CMS-concurrent-preclean-start]\n5:\t7.905: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] \n6:\t7.905: [CMS-concurrent-abortable-preclean-start]\n7:\t7.986: [GC (Allocation Failure) 7.986: [ParNew: 38926K->4352K(39296K), 0.0067288 secs] 76189K->43991K(126720K), 0.0067888 secs] \n                [Times: user=0.00 sys=0.00, real=0.01 secs] \n8:\t8.102: [GC (Allocation Failure) 8.102: [ParNew8.120: [CMS-concurrent-abortable-preclean: 0.034/0.214 secs] \n                [Times: user=0.33 sys=0.02, real=0.22 secs] \n\t: 39296K->876K(39296K), 0.0335647 secs] 78935K->40751K(126720K), 0.0336238 secs] [Times: user=0.13 sys=0.00, real=0.03 secs] \n9:\t8.136: [GC (CMS Final Remark) [YG occupancy: 1569 K (39296 K)]8.136: [Rescan (parallel) , 0.0026637 secs]\n        8.139: [weak refs processing, 0.0004099 secs]\n        8.139: [class unloading, 0.0049642 secs]\n        8.144: [scrub symbol table, 0.0053784 secs]\n        8.149: [scrub string table, 0.0006631 secs][1 CMS-remark: 39874K(87424K)] 41443K(126720K), 0.0144267 secs] \n                [Times: user=0.02 sys=0.00, real=0.01 secs] \n10:\t8.150: [CMS-concurrent-sweep-start]\n11:\t8.161: [CMS-concurrent-sweep: 0.010/0.011 secs] [Times: user=0.03 sys=0.02, real=0.01 secs] \n12:\t8.161: [CMS-concurrent-reset-start]\n13:\t8.162: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n")])])]),e("p",[e("strong",[a._v("日志说明:")])]),a._v(" "),e("ul",[e("li",[a._v("第1行\n"),e("code",[a._v("CMS Initial Mark")]),a._v("说明开始初始标记，此时会停顿所有java线程， "),e("code",[a._v("37262K")]),a._v("是当前java堆的使用量， "),e("code",[a._v("87424K")]),a._v("是java堆的总量，因为这段gc日志是在我的程序启动过程中的，所以看到后面还有"),e("code",[a._v("42307K(126720K)")]),a._v("，说明在启动过程中，java堆内存在扩大。")]),a._v(" "),e("li",[a._v("第2行\n开始并发标记，此时是和java线程并发执行。")]),a._v(" "),e("li",[a._v("第3行\n显式了并发标记的时间。")]),a._v(" "),e("li",[a._v("第4行\n开始并发预清除，也就是对并发标记阶段发生引用变化的对象进行重新标记。")]),a._v(" "),e("li",[a._v("第5行\n显式了并发预清除的执行时间。")]),a._v(" "),e("li",[a._v("第6行\n开始终止并发预清除。")]),a._v(" "),e("li",[a._v("第7行\n这是一次MinorGC日志，这也说明了在CMS并发阶段，也可能会进行MinorGC，此处的"),e("code",[a._v("76189K->43991K(126720K)")]),a._v("可以看出在CMS并发清除前，这次MonorGC后，java堆的使用量为43991K。")]),a._v(" "),e("li",[a._v("第8行\n终止并发预清除，此时依然穿插了一次MinorGC。")]),a._v(" "),e("li",[a._v("第9行\n进行最后标记， "),e("code",[a._v("CMS-remark: 39874K(87424K)] 41443K(126720K)")]),a._v("中可以看出当前java堆总量为126720K，使用量为41443K。")]),a._v(" "),e("li",[a._v("第10行\n开始并发清除。")]),a._v(" "),e("li",[a._v("第11行\n显式并发清除执行时间。")]),a._v(" "),e("li",[a._v("第12行\n重置并发，表示一个CMS清除周期完毕。")])]),a._v(" "),e("p",[a._v("注意CMS并发清除开始和结束时的MinorGC，如果java堆的占用几乎没有怎么降低，很少有对象被回收，说明该轮CMS垃圾收集周期几乎没有找到垃圾对象而只是在浪费cpu，或者对象以不小于CMS并行清除垃圾对象的速度被提升到老年代。这两种情况都说明jvm需要调优，具体的调优请看后面专门的章节，此章节主要讲解如何理解GC日志。")]),a._v(" "),e("p",[a._v("如果对象提升到老年代的速度太快，而CMS收集器不能保持足够多的可用空间时，就会导致老年代的运行空间不足，这成为并发模式失败。当老年代碎片化达到某种程度，使得没有足够空间容纳新提升的对象时，也会引发并发模式失败。\n当出现并发模式失败时，CMS的GC日志会有”"),e("strong",[a._v("concurrent mode failure")]),a._v("”。发生并发模式失败时，老年代将以STW的方式进行垃圾收集，并且整理压缩碎片。")]),a._v(" "),e("p",[e("strong",[a._v("作为一般性准则，并发垃圾收集的开销应该小于10%，也有可能达到1-3%。")])]),a._v(" "),e("h3",{attrs:{id:"_1-6-补充"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-补充"}},[a._v("#")]),a._v(" 1.6 补充")]),a._v(" "),e("p",[a._v("使用 "),e("code",[a._v("–XX:+PrintGCApplicationConcurrentTime")]),a._v(" 和 "),e("code",[a._v("–XX:+PrintGCApplicationStoppedTime")]),a._v("，jvm可以报告应用在安全点操作之间的运行时间，以及阻塞java线程的时间。\n利用这俩个选项观察安全点操作有助于理解和量化延迟对jvm的影响，也可以用来辨别jvm安全点操作还是应用程序引入的延迟。")]),a._v(" "),e("p",[a._v("一段日志示例:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("8.752: Application time: 0.1273273 seconds    //此处延迟由MinorGC造成\n8.752: [GC (Allocation Failure) 8.752: [ParNew: 38435K->433K(39296K), 0.0020703 secs] 73597K->35763K(126720K), 0.0021173 secs] \n        [Times: user=0.00 sys=0.00, real=0.00 secs] \n8.754: Total time for which application threads were stopped: 0.0022436 seconds, Stopping threads took: 0.0000156 seconds    \n8.754: Application time: 0.0001583 seconds    //此处延迟由应用本身引入\n8.754: Total time for which application threads were stopped: 0.0001487 seconds, Stopping threads took: 0.0000837 seconds\n")])])]),e("p",[a._v("通过命令行选项 "),e("code",[a._v("-XX:+DisableExplicitGC")]),a._v(" 可以禁用System.gc()。")]),a._v(" "),e("h2",{attrs:{id:"_2-jconsole"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-jconsole"}},[a._v("#")]),a._v(" 2. JConsole")]),a._v(" "),e("p",[a._v("JConsole是一款随jdk发布的图形化jvm监控工具。")]),a._v(" "),e("h3",{attrs:{id:"_2-1-启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-启动"}},[a._v("#")]),a._v(" 2.1 启动")]),a._v(" "),e("p",[a._v("在jdk安装目录的bin目录中可以找到jconsole，如下图：")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/2.1.png",alt:"img"}})]),a._v(" "),e("p",[a._v("在windows操作系统中，可以直接双击打开，也可以通过命令行打开。")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/2.2.png",alt:"img"}})]),a._v(" "),e("h3",{attrs:{id:"_2-2-连接jvm应用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-连接jvm应用"}},[a._v("#")]),a._v(" 2.2 连接jvm应用")]),a._v(" "),e("p",[a._v("选择上图中pid为7420的应用，点击连接。")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/2.3.png",alt:"img"}})]),a._v(" "),e("h3",{attrs:{id:"_2-3-连接成功"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-连接成功"}},[a._v("#")]),a._v(" 2.3 连接成功")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/2.4.png",alt:"img"}})]),a._v(" "),e("h3",{attrs:{id:"_2-4-内存监控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-内存监控"}},[a._v("#")]),a._v(" 2.4 内存监控")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/2.5.png",alt:"img"}})]),a._v(" "),e("p",[a._v("补充：监控时可以留意一下Survivor是否长时间处于满状态，如果是，说明Survivor已经溢出，对象在老化之前就被提升到老年代，对新生代调优可以解决该问题。")]),a._v(" "),e("h3",{attrs:{id:"_2-5-线程监控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-线程监控"}},[a._v("#")]),a._v(" 2.5 线程监控")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/2.6.png",alt:"img"}})]),a._v(" "),e("h3",{attrs:{id:"_2-6-类加载监控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-类加载监控"}},[a._v("#")]),a._v(" 2.6 类加载监控")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/2.7.png",alt:"img"}})]),a._v(" "),e("h3",{attrs:{id:"_2-7-vm概要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-vm概要"}},[a._v("#")]),a._v(" 2.7 VM概要")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/2.8.png",alt:"img"}})]),a._v(" "),e("p",[a._v("以文本形式显式当前时间jvm中各项监控指标的数据")]),a._v(" "),e("h3",{attrs:{id:"_2-8-mbean监控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-mbean监控"}},[a._v("#")]),a._v(" 2.8 MBean监控")]),a._v(" "),e("p",[a._v("此界面列出了所有MBean，可以点击相应的MBean查看属性状态 。")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/2.9.png",alt:"img"}})]),a._v(" "),e("h2",{attrs:{id:"_3-visualvm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-visualvm"}},[a._v("#")]),a._v(" 3. VisualVM")]),a._v(" "),e("p",[a._v("VisualVM也是一款随jdk发布的图形化监测工具。")]),a._v(" "),e("h3",{attrs:{id:"_3-1-启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-启动"}},[a._v("#")]),a._v(" 3.1 启动")]),a._v(" "),e("p",[a._v("在jdk安装目录的bin目录中,可以找到jvisualvm,如下图:\n"),e("img",{attrs:{src:"/img/java/jvm/3.1.png",alt:"img"}})]),a._v(" "),e("p",[a._v("在windows操作系统中,可以直接双击运行,也可以通过命令行运行\n"),e("img",{attrs:{src:"/img/java/jvm/3.2.png",alt:"img"}})]),a._v(" "),e("h3",{attrs:{id:"_3-2-概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-概述"}},[a._v("#")]),a._v(" 3.2 概述")]),a._v(" "),e("p",[a._v("应用打开后，自动进入概述页面，此页面以文本形式列出了当前应用的一些基础信息。\n"),e("img",{attrs:{src:"/img/java/jvm/3.3.png",alt:"img"}})]),a._v(" "),e("h3",{attrs:{id:"_3-3-监控"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-监控"}},[a._v("#")]),a._v(" 3.3 监控")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/3.4.png",alt:"img"}}),a._v("\nVisualVM默认将四个jvm监控指标放在了一起，每个指标的监控图与JConsole相比，没有JConsole数据详细，但是图形化要比JConsole更加直观。")]),a._v(" "),e("h3",{attrs:{id:"_3-4-线程详情监测"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-线程详情监测"}},[a._v("#")]),a._v(" 3.4 线程详情监测")]),a._v(" "),e("p",[e("img",{attrs:{src:"/img/java/jvm/3.5.png",alt:"img"}}),a._v("\nVisualVM通过不同的颜色标记线程状态，相比JConsole，更加直观，但是却没有了JConsole中的堆栈追踪信息，在分析线程等待原因及死锁上不如JConsole。")]),a._v(" "),e("h3",{attrs:{id:"_3-5-抽样器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-抽样器"}},[a._v("#")]),a._v(" 3.5 抽样器")]),a._v(" "),e("p",[a._v("可以随时对cpu和内存进行抽样，后期出现问题时可以通过对不同时间点的抽样数据来查找原因。\n"),e("img",{attrs:{src:"/img/java/jvm/3.6.png",alt:"img"}})]),a._v(" "),e("h3",{attrs:{id:"_3-6-性能分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-性能分析"}},[a._v("#")]),a._v(" 3.6 性能分析")]),a._v(" "),e("p",[a._v("可以对当前cpu和内存的状态进行性能分析。\n"),e("img",{attrs:{src:"/img/java/jvm/3.7.png",alt:"img"}})]),a._v(" "),e("h2",{attrs:{id:"_4-jatack"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-jatack"}},[a._v("#")]),a._v(" 4. jatack")]),a._v(" "),e("p",[a._v("快速定位java应用中的锁竞争，常用的技巧是用jdk的jatack抓取线程转储信息，监控锁竞争。")]),a._v(" "),e("p",[e("strong",[a._v("jatack命令格式")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("jstack [ option ] pid \njstack [ option ] executable core \njstack [ option ] [server-id@]remote-hostname-or-IP\n")])])]),e("p",[e("strong",[a._v("常用参数说明")])]),a._v(" "),e("ul",[e("li",[e("p",[a._v("options")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("executable")]),a._v(" "),e("br"),a._v("Java executable from which the core dump was produced.(可能是产生core dump的java可执行程序)。")]),a._v(" "),e("li",[e("code",[a._v("core")]),a._v(" "),e("br"),a._v("将被打印信息的core dump文件。")]),a._v(" "),e("li",[e("code",[a._v("remote-hostname-or-IP")]),a._v(" "),e("br"),a._v("远程debug服务的主机名或ip。")]),a._v(" "),e("li",[e("code",[a._v("server-id")]),a._v(" "),e("br"),a._v("唯一id,假如一台主机上多个远程debug服务。")])])]),a._v(" "),e("li",[e("p",[a._v("基本参数")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("-F")]),a._v(" "),e("br"),a._v("当’jstack [-l] pid’没有相应的时候强制打印栈信息。")]),a._v(" "),e("li",[e("code",[a._v("-l")]),a._v(" "),e("br"),a._v("长列表。打印关于锁的附加信息，例如属于java.util.concurrent的ownable synchronizers列表。")]),a._v(" "),e("li",[e("code",[a._v("-m")]),a._v(" "),e("br"),a._v("打印java和native c/c++框架的所有栈信息，可以打印JVM的堆栈。")]),a._v(" "),e("li",[e("code",[a._v("-h | -help")]),a._v(" "),e("br"),a._v("打印帮助信息。")]),a._v(" "),e("li",[e("code",[a._v("pid")]),a._v(" "),e("br"),a._v("需要被打印配置信息的java进程id，可以用jps查询。")])])])]),a._v(" "),e("p",[e("strong",[a._v("抓取日志示例")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('"http-nio-8080-ClientPoller-0" #52 daemon prio=5 os_prio=0 tid=0x000000005f164000 nid=0x13a0 runnable [0x0000000061cee000]\n   java.lang.Thread.State: RUNNABLE\n        at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method)\n        at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(WindowsSelectorImpl.java:296)\n        at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(WindowsSelectorImpl.java:278)\n        at sun.nio.ch.WindowsSelectorImpl.doSelect(WindowsSelectorImpl.java:159)\n        at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)\n        - locked <0x00000000ad3b1d38> (a sun.nio.ch.Util$2)\n        - locked <0x00000000ad3d56d8> (a java.util.Collections$UnmodifiableSet)\n        - locked <0x00000000ad3ba000> (a sun.nio.ch.WindowsSelectorImpl)\n        at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)\n        at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:787)\n        at java.lang.Thread.run(Thread.java:745)\n\n   Locked ownable synchronizers:\n        - None\n\n"http-nio-8080-exec-10" #51 daemon prio=5 os_prio=0 tid=0x000000005f163000 nid=0x1de8 waiting on condition [0x0000000061ace000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000ad4dbc58> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)\n        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)\n        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)\n        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n        at java.lang.Thread.run(Thread.java:745)\n\n   Locked ownable synchronizers:\n        - None\n\n"http-nio-8080-exec-9" #50 daemon prio=5 os_prio=0 tid=0x000000005f162800 nid=0x219c waiting on condition [0x000000006191e000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000ad4dbc58> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)\n        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)\n        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)\n        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n        at java.lang.Thread.run(Thread.java:745)\n\n   Locked ownable synchronizers:\n        - None\n\n"http-nio-8080-exec-8" #49 daemon prio=5 os_prio=0 tid=0x000000005f161800 nid=0x202c waiting on condition [0x0000000060e0e000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x00000000ad4dbc58> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)\n        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)\n        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)\n        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)\n        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1067)\n        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1127)\n        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n        at java.lang.Thread.run(Thread.java:745)\n\n   Locked ownable synchronizers:\n        - None\n')])])]),e("p",[a._v("上面是一段jstack日志，可以看到很多这种格式 "),e("code",[a._v("waiting on condition [0x0000000060e0e000]")]),a._v(" 的文本，说明线程正在等待获取某个锁，中括号中的一串标识就是锁地址。每个锁在jatack日志中的标识都是唯一的，如果多个线程在等待同一个标识，那么说明在竞争同一个锁。jstack对追踪锁竞争和查看锁竞争激烈程度十分有用，对分析死锁也很有用。")])])}),[],!1,null,null,null);e.default=n.exports}}]);