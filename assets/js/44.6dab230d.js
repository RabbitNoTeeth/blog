(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{330:function(i,n,t){"use strict";t.r(n);var s=t(7),e=Object(s.a)({},(function(){var i=this,n=i._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[n("p",[i._v("静态工厂和构建器有个共同的局限性：它们都不能很好地扩展到大量的可选参数。下面我们将通过一个示例来对比各种对于大量可选参数的解决办法。")]),i._v(" "),n("h2",{attrs:{id:"_1-构造器重载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-构造器重载"}},[i._v("#")]),i._v(" 1. 构造器重载")]),i._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[i._v("public class NutritionFacts {\n\n    private final int servingSize;  //必需\n    private final int servings;     //必需\n    private final int calories;     //可选\n    private final int fat;          //可选\n    private final int sodium;       //可选\n\n    public NutritionFacts(int servingSize, int servings){\n        this(servingSize,servings,0);\n    }\n\n    public NutritionFacts(int servingSize, int servings, int calories){\n        this(servingSize,servings,calories,0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings, int calories, int fat){\n        this(servingSize,servings,calories,fat,0);\n    }\n    \n    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium){\n        this.servingSize = servingSize;\n        this.servings = servings;\n        this.calories = calories;\n        this.fat = fat;\n        this.sodium = sodium;\n    }\n\n}\n")])])]),n("p",[i._v("构造器重载方式可行，但是当有更多的参数时，客户端代码很难编写，并且难以阅读。")]),i._v(" "),n("h2",{attrs:{id:"_2-javabeans-模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-javabeans-模式"}},[i._v("#")]),i._v(" 2. JavaBeans 模式")]),i._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[i._v("public class NutritionFacts {\n\n    private int servingSize;  //必需\n    private int servings;     //必需\n    private int calories;     //可选\n    private int fat;          //可选\n    private int sodium;       //可选\n\n    public NutritionFacts(){ }\n\n    public void setServingSize(int servingSize) {\n        this.servingSize = servingSize;\n    }\n\n    public void setServings(int servings) {\n        this.servings = servings;\n    }\n\n    public void setCalories(int calories) {\n        this.calories = calories;\n    }\n\n    public void setFat(int fat) {\n        this.fat = fat;\n    }\n\n    public void setSodium(int sodium) {\n        this.sodium = sodium;\n    }\n}\n")])])]),n("p",[i._v("这种模式弥补了构造器重载模式的不足，创建实例很容易并且代码可读性好。\n但是该模式有一个很严重的缺陷：因为构造过程被划分为多个不同的调用，在构造过程可能引起状态不一致的问题，可以说JavaBeans模式阻止了把类做成不可变的可能。")]),i._v(" "),n("h2",{attrs:{id:"_3-builder-模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-builder-模式"}},[i._v("#")]),i._v(" 3. Builder 模式")]),i._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[i._v("public class NutritionFacts {\n\n    private int servingSize;  //必需\n    private int servings;     //必需\n    private int calories;     //可选\n    private int fat;          //可选\n    private int sodium;       //可选\n\n    private NutritionFacts(Builder builder){ \n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        fat = builder.fat;\n        sodium = builder.sodium;\n    }\n\n    public static class Builder{\n        private final int servingSize;  //必需\n        private final int servings;     //必需\n        private int calories = 0;       //可选\n        private int fat = 0;            //可选\n        private int sodium = 0;         //可选\n        \n        public Builder(int servingSize, int servings){\n            this.servingSize = servingSize;\n            this.servings = servings;\n        }\n        \n        public Builder calories(int calories){\n            this.calories = calories;\n            return this;\n        }\n\n        public Builder fat(int fat){\n            this.fat = fat;\n            return this;\n        }\n\n        public Builder sodium(int sodium){\n            this.sodium = sodium;\n            return this;\n        }\n        \n        public NutritionFacts build(){\n            return new NutritionFacts(this);\n        }\n        \n    }\n}\n\n调用代码:\nNutritionFacts facts = new Builder(20, 50).calories(30).fat(10).sodium(60).build();\n")])])]),n("p",[i._v("Builder模式弥补了上述两者的不足，客户端代码写起来很容易并且可读性强，同时，在build方法中可以添加对参数的校验。")]),i._v(" "),n("p",[i._v("如果Builder模式使用较多时，可以通过定义统一的泛型接口来管理：")]),i._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[i._v("public interface Builder<T> {\n    T build();\n}\n")])])]),n("p",[i._v("**Builder模式的缺点：**为了创建对象，需要先创建它的构建器，如果对性能要求十分苛刻，那么此处就成为了一个需要解决的问题；同时，其代码也更加冗长，因此一般只有参数数量大于4时才推荐使用。")]),i._v(" "),n("p",[n("strong",[i._v("总结")])]),i._v(" "),n("p",[i._v("如果类的构造器或者静态工厂中具有多个参数，在设计时，Builder模式是不错的选择，特别是当大多数参数都是可选的时候。")])])}),[],!1,null,null,null);n.default=e.exports}}]);