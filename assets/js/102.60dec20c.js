(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{395:function(t,e,v){"use strict";v.r(e);var _=v(7),a=Object(_.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("在vert.x的使用中，我使用最多的是用vert.x来构建http服务，对于绝大多数web应用而言，数据库操作是必不可少的，而数据库操作是阻塞式的。")]),t._v(" "),e("p",[t._v("vert.x官方重点说明了一条黄金法则："),e("code",[t._v("The Golden Rule - Don’t Block the Event Loop")]),t._v("，也就是不要阻塞 event loop。对于http请求的处理，默认是在 event loop 中，如果请求中需要进行比较耗时的数据库操作，那么最好是将这个操作通过其他线程处理。 vert.x提供了 "),e("code",[t._v("Vertx.executeBlocking")]),t._v(" 方法来处理阻塞操作，比如数据库操作。")]),t._v(" "),e("h2",{attrs:{id:"_1-出现问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-出现问题"}},[t._v("#")]),t._v(" 1. 出现问题")]),t._v(" "),e("p",[t._v("在Java21中，虚拟线程已经正式发布，我将http请求的处理全部转移到虚拟线程中，经过测试后，发现一个问题。")]),t._v(" "),e("p",[t._v("目前，应用中有几个耗时较长的查询接口，部署到生产服务器后，接口响应时间在6s左右，客户端每次请求这些接口，都会在5s后直接响应失败，查看相关日志后，发现是服务端主动断开连接。好吧，开始排查...")]),t._v(" "),e("h2",{attrs:{id:"_2-排查问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-排查问题"}},[t._v("#")]),t._v(" 2. 排查问题")]),t._v(" "),e("p",[t._v("查看服务端代码，http相关设置，发现 "),e("code",[t._v("idleTimeout")]),t._v(" 属性设置为5s，即连接空闲5s后关闭连接。")]),t._v(" "),e("p",[t._v("分析原因：将请求处理代码放到虚拟线程执行后，event loop会认为该连接已空闲，达到指定时间后关闭了连接。")]),t._v(" "),e("h2",{attrs:{id:"_3-修改代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-修改代码"}},[t._v("#")]),t._v(" 3. 修改代码")]),t._v(" "),e("p",[t._v("设置 "),e("code",[t._v("idleTimeout")]),t._v(" 属性为10s，部署测试。")]),t._v(" "),e("h2",{attrs:{id:"_4-验证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-验证"}},[t._v("#")]),t._v(" 4. 验证")]),t._v(" "),e("p",[t._v("问题解决。")])])}),[],!1,null,null,null);e.default=a.exports}}]);