(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{359:function(t,e,n){"use strict";n.r(e);var a=n(7),i=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("对于一个对象来说，理想化的序列化形式应该只包括该对象所表示的逻辑数据，而逻辑数据与物理表示法应该是各自独立的。")]),t._v(" "),e("h2",{attrs:{id:"_1-何时可以使用默认的序列化形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-何时可以使用默认的序列化形式"}},[t._v("#")]),t._v(" 1. 何时可以使用默认的序列化形式?")]),t._v(" "),e("p",[t._v("如果一个对象的物理表示法等同于它的逻辑内容，那么就可以接受默认的序列化形式。")]),t._v(" "),e("p",[e("strong",[t._v("代码示例:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//代码示例1\npublic class Name implements Serializable {\n    \n    private final String firstName;\n    \n    private final String lastName;\n\n    public Name(String firstName, String lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n}\n")])])]),e("p",[t._v("在Name类中，实例域就是逻辑内容，所以它可以使用默认的序列化形式。")]),t._v(" "),e("p",[t._v("如果确定使用默认的序列化形式是合理的，通常还必须提供一个readObject方法来保证约束关系和安全性，例如在Name类中添加：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n    in.defaultReadObject();\n    if(firstName==null || lastName==null)\n        throw new IllegalArgumentException("firstName or lastName can not be null");\n}\n')])])]),e("h2",{attrs:{id:"_2-何时使用自定义的序列化形式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-何时使用自定义的序列化形式"}},[t._v("#")]),t._v(" 2. 何时使用自定义的序列化形式?")]),t._v(" "),e("p",[e("strong",[t._v("一个错误接受默认序列化形式的示例:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//代码清单2\npublic class StringList implements Serializable{\n    \n    private int size = 0;\n    private Entry head = null;\n    \n    private static class Entry implements Serializable{\n        String data;\n        Entry next;\n        Entry previous;\n    }\n}\n")])])]),e("p",[t._v("上面StringList表示一个字符串类，其接受了默认的序列化形式。当然，从程序的正确性上讲，是没有问题的，但是从优化角度看，这样做是非常错误的。因为对于StrngList类来说，内部的Entry实现的链表结构只是物理表示，而StrngList的真正逻辑数据就是一个个字符，把Entry等内容序列化到输出流是没有必要的。这样会增加时间和空间的成本，甚至会引起栈溢出。")]),t._v(" "),e("p",[e("strong",[t._v("使用自定义的序列化形式来优化StringList:")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//代码清单3\npublic class StringList implements Serializable{\n\n    private transient int size = 0;         \n    private transient Entry head = null;\n    \n    private List<String> list = new ArrayList<>();\n\n    private static class Entry implements Serializable{\n        String data;\n        Entry next;\n        Entry previous;\n    }\n    \n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(size);\n        for(Entry e = head;e != null;e = e.next){\n            out.writeObject(e.data);        //只将链表中的String写入到序列流中\n        }\n    }\n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        int size = in.readInt();\n        for(int i=0;i<size;i++){\n            list.add((String) in.readObject());\n        }\n    }\n}\n")])])]),e("p",[t._v("transient修饰符表示这个实例域将从一个类的默认序列化形式中省略掉。")]),t._v(" "),e("p",[t._v("即便所有的域都是transient瞬时的，也推荐调用defaultReadObject和defaultWriteObject方法。当defaultWriteObject方法被调用时，每个未被标记为transient的实例都将被序列化。")]),t._v(" "),e("p",[t._v("在决定将一个域做成非transient的之前，请一定要确信它的值将是该对象逻辑状态的一部分。")]),t._v(" "),e("p",[t._v("对于被transient标记的域，当一个实例被反序列化的时候，这些域将被初始化为它们的默认值(引用类型为null，基本类型为其默认值)。如果这些值不能被任何transient域所接受，你就必须提供一个readObject方法，它首先调用defaultReadObject，然后把这些transient域恢复为可接受的值。或者通过延迟初始化在方法中实现。")]),t._v(" "),e("p",[t._v("如果在读取整个对象状态的任何其他方法上强制任何同步，也必须在序列化上强制这些同步。同时要使用相同的锁。")]),t._v(" "),e("p",[t._v("不管选择哪一种序列化形式，都应该提供显式的UID标识号。")])])}),[],!1,null,null,null);e.default=i.exports}}]);