(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{381:function(e,t,a){"use strict";a.r(t);var n=a(7),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"_1-nio和bio的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-nio和bio的区别"}},[e._v("#")]),e._v(" 1. NIO和BIO的区别")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("BIO是面向流的，NIO是面向缓冲区的。")]),e._v(" "),t("p",[e._v("BIO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。")]),e._v(" "),t("p",[e._v("NIO则将数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。")])]),e._v(" "),t("li",[t("p",[e._v("BIO的各种流是阻塞的，而NIO支持非阻塞模式IO。")]),e._v(" "),t("p",[e._v("在BIO中，当一个线程调用"),t("code",[e._v("read()")]),e._v(" 或 "),t("code",[e._v("write()")]),e._v("时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。")]),e._v(" "),t("p",[e._v("NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。")])])]),e._v(" "),t("h2",{attrs:{id:"_2-核心组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-核心组件"}},[e._v("#")]),e._v(" 2. 核心组件")]),e._v(" "),t("h3",{attrs:{id:"_2-1-buffer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-buffer"}},[e._v("#")]),e._v(" 2.1 Buffer")]),e._v(" "),t("p",[e._v("Buffer，缓冲区，实际上是一个数组容器。")]),e._v(" "),t("p",[e._v("Channel从网络或者文件等读取的数据都必须经过Buffer。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/java/javase/io/1.1.jpg",alt:"img"}})]),e._v(" "),t("p",[e._v("Java nio提供了多种Buffer实现，如"),t("code",[e._v("ByteBuffer")]),e._v("、"),t("code",[e._v("CharBuffer")]),e._v("、"),t("code",[e._v("DoubleBuffer")]),e._v("、"),t("code",[e._v("FloatBuffer")]),e._v("、"),t("code",[e._v("IntBuffer")]),e._v("、"),t("code",[e._v("LongBuffer")]),e._v("、"),t("code",[e._v("ShortBuffer")]),e._v("，分别对应各种基本数据类型。还有"),t("code",[e._v("MappedByteBuffer")]),e._v("、"),t("code",[e._v("HeapByteBuffer")]),e._v("、"),t("code",[e._v("DirectByteBuffer")]),e._v("等适用于特殊场景的实现。")]),e._v(" "),t("h4",{attrs:{id:"_2-1-1-内部模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-内部模型"}},[e._v("#")]),e._v(" 2.1.1 内部模型")]),e._v(" "),t("p",[e._v("Buffer类中定义了四个变量：capacity、position、limit、mark。")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[e._v("变量")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("说明")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("capacity")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("缓冲区数组的总长度，默认大小为数组长度")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("position")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("下一个要操作的元素的位置，默认为0")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("limit")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("缓冲区数组中不可操作的下一个元素的位置：limit<=capacity，默认大小为数组长度")])]),e._v(" "),t("tr",[t("td",{staticStyle:{"text-align":"center"}},[e._v("mark")]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[e._v("用于记录当前position，默认为-1")])])])]),e._v(" "),t("p",[e._v("下面，以ByteBuffer为例，通过对其常用方法进行说明，来了解上述四个变量是如何工作的。")]),e._v(" "),t("h4",{attrs:{id:"_2-1-2-allocate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-allocate"}},[e._v("#")]),e._v(" 2.1.2 allocate")]),e._v(" "),t("p",[e._v("分配指定大小的HeapByteBuffer，HeapByteBuffer属于堆缓冲区，是ByteBuffer的一种实现，也是我们常用的ByteBuffer实现，因为是在java堆内存中，所以其能被快速分配，并且能被垃圾收集器收集释放。")]),e._v(" "),t("h4",{attrs:{id:"_2-1-2-allocatedirect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-allocatedirect"}},[e._v("#")]),e._v(" 2.1.2 allocateDirect")]),e._v(" "),t("p",[e._v("分配指定大小的DirectByteBuffer，DirectByteBuffer不在堆内存中，所以不存在由于垃圾收集引起的复制操作。但是其主要缺点是分配和释放比较昂贵，并且需要程序员手动释放。")]),e._v(" "),t("p",[e._v("在调用"),t("code",[e._v("ByteBuffer.allocate(11)")]),e._v("后，ByteBuffer内部数组可以用下面的图示表示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/java/javase/io/1.2.png",alt:"img"}})]),e._v(" "),t("p",[e._v("此时position=0，mark=-1，capacity=limit=10。")]),e._v(" "),t("h4",{attrs:{id:"_2-1-3-向bytebuffer写入5个字节"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-3-向bytebuffer写入5个字节"}},[e._v("#")]),e._v(" 2.1.3 向ByteBuffer写入5个字节")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/java/javase/io/1.3.jpg",alt:"img"}})]),e._v(" "),t("p",[e._v("此时position=5，mark=4，capacity=limit=10。")]),e._v(" "),t("h4",{attrs:{id:"_2-1-4-flip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-4-flip"}},[e._v("#")]),e._v(" 2.1.4 flip")]),e._v(" "),t("p",[e._v("通俗来理解，flip方法就是标记出当前数组中可以读取的数据。在使用中，通常要先调用flip方法，标记出ByteBuffer中可读取的数据起始和结束位置，然后将数据读取到channel中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final Buffer flip() {\n    limit = position;\n    position = 0;\n    mark = -1;\n    return this;\n}\n")])])]),t("p",[e._v("承接上面的图示:")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/java/javase/io/1.4.png",alt:"img"}})]),e._v(" "),t("h4",{attrs:{id:"_2-1-5-clear"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-5-clear"}},[e._v("#")]),e._v(" 2.1.5 clear")]),e._v(" "),t("p",[e._v("clear方法会将position、limit、mark全部置为初始值。此时如果数组中还有未读数据，那么这些数据就会被”遗忘”，无法再获取到这些数据，并且在向数组中写入新数据时，会覆盖这些遗留数据。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final Buffer clear() {\n    position = 0;\n    limit = capacity;\n    mark = -1;\n    return this;\n}\n")])])]),t("h4",{attrs:{id:"_2-1-6-compact"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-6-compact"}},[e._v("#")]),e._v(" 2.1.6 compact")]),e._v(" "),t("p",[e._v("compact方法会将数组中的未读数据拷贝到数组起始处，然后将position设置为最后一位未读数据的下一步，在向数组写入新数据时，会在position处开始写入，不会覆盖掉原有的未读数据。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public ByteBuffer compact() {\n    System.arraycopy(hb, ix(position()), hb, ix(0), remaining());\n    position(remaining());\n    limit(capacity());\n    discardMark();\n    return this;\n}\n")])])]),t("h4",{attrs:{id:"_2-1-7-position"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-7-position"}},[e._v("#")]),e._v(" 2.1.7 position")]),e._v(" "),t("p",[e._v("将position置于newPosition位置，可用于读取newPosition到limit部分的数据。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final Buffer position(int newPosition) {\n    if ((newPosition > limit) || (newPosition < 0))\n        throw new IllegalArgumentException();\n    position = newPosition;\n    if (mark > position) mark = -1;\n    return this;\n}\n")])])]),t("h4",{attrs:{id:"_2-1-8-limit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-8-limit"}},[e._v("#")]),e._v(" 2.1.8 limit")]),e._v(" "),t("p",[e._v("limit方法用于更新limit位置，可以用于限制读取position到newLimit之间的数据。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final Buffer limit(int newLimit) {\n    if ((newLimit > capacity) || (newLimit < 0))\n        throw new IllegalArgumentException();\n    limit = newLimit;\n    if (position > limit) position = limit;\n    if (mark > limit) mark = -1;\n    return this;\n}\n")])])]),t("h4",{attrs:{id:"_2-1-9-mark-和-reset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-9-mark-和-reset"}},[e._v("#")]),e._v(" 2.1.9 mark 和 reset")]),e._v(" "),t("p",[e._v("mark方法会标记当前position。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final Buffer mark() {\n    mark = position;\n    return this;\n}\n")])])]),t("p",[e._v("reset方法用于恢复用"),t("code",[e._v("mark()")]),e._v("方法标记的position位置。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final Buffer reset() {\n    int m = mark;\n    if (m < 0)\n        throw new InvalidMarkException();\n    position = m;\n    return this;\n}\n")])])]),t("h4",{attrs:{id:"_2-1-10-rewind"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-10-rewind"}},[e._v("#")]),e._v(" 2.1.10 rewind")]),e._v(" "),t("p",[e._v("rewind方法会重置position，limit保持不变，可用于重复读取数组中的数据。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public final Buffer rewind() {\n    position = 0;\n    mark = -1;\n    return this;\n}\n")])])]),t("h3",{attrs:{id:"_2-2-channel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-channel"}},[e._v("#")]),e._v(" 2.2 Channel")]),e._v(" "),t("p",[e._v("通常来说，所有的 NIO 的 I/O 操作都是从 Channel 开始的。一个 channel 类似于一个 stream。")]),e._v(" "),t("h4",{attrs:{id:"_2-2-1-java-stream-和-nio-channel-对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-1-java-stream-和-nio-channel-对比"}},[e._v("#")]),e._v(" 2.2.1 java Stream 和 NIO Channel 对比")]),e._v(" "),t("p",[e._v("同一个 Channel 中可以执行读和写操作，然而同一个 Stream 仅仅支持读或写。")]),e._v(" "),t("p",[e._v("Channel 可以异步地读写，而 Stream 是阻塞的同步读写。")]),e._v(" "),t("p",[e._v("Channel 总是从 Buffer 中读取数据，或将数据写入到 Buffer 中。")]),e._v(" "),t("h4",{attrs:{id:"_2-2-2-channel-类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-2-channel-类型"}},[e._v("#")]),e._v(" 2.2.2 Channel 类型")]),e._v(" "),t("ol",[t("li",[t("p",[t("code",[e._v("FileChannel")]),e._v("：文件操作")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("DatagramChannel")]),e._v("：UDP 操作")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("SocketChannel")]),e._v("：TCP 操作")])]),e._v(" "),t("li",[t("p",[t("code",[e._v("ServerSocketChannel")]),e._v("：TCP 操作，使用在服务器端")]),e._v(" "),t("p",[e._v("这些通道涵盖了 UDP 和 TCP网络 IO以及文件 IO。")])])]),e._v(" "),t("h4",{attrs:{id:"_2-2-3-使用示例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-使用示例"}},[e._v("#")]),e._v(" 2.2.3 使用示例")]),e._v(" "),t("h5",{attrs:{id:"_2-2-3-1-文件io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-1-文件io"}},[e._v("#")]),e._v(" 2.2.3.1 文件IO")]),e._v(" "),t("p",[t("strong",[e._v("读取文件")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public  static void read() throws Exception {\n    RandomAccessFile file = new RandomAccessFile("C:\\\\Users\\\\Administrator\\\\Desktop\\\\jstatd.all.policy","rw");\n    FileChannel channel = file.getChannel();\n    ByteBuffer buffer = ByteBuffer.allocate(10);\n    int i = channel.read(buffer);\n    while (i != -1){\n        buffer.flip();\n        while (buffer.hasRemaining()){\n            System.out.print((char) buffer.get());\n        }\n        buffer.clear();\n        i = channel.read(buffer);\n    }\n    channel.close();\n    file.close();\n}\n')])])]),t("p",[t("strong",[e._v("写入文件")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public static void write() throws Exception{\n\n    RandomAccessFile file = new RandomAccessFile("C:\\\\Users\\\\Administrator\\\\Desktop\\\\aaa.txt","rw");\n    FileChannel channel = file.getChannel();\n    String str = "i am writing some text into file! now=" + System.nanoTime();\n    ByteBuffer buffer = ByteBuffer.allocate(1024);\n    buffer.clear();\n    buffer.put(str.getBytes("utf-8"));\n    buffer.flip();\n    while (buffer.hasRemaining()){\n        channel.write(buffer);\n    }\n    channel.close();\n    file.close();\n\n}\n')])])]),t("h4",{attrs:{id:"_2-2-3-2-tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-2-tcp"}},[e._v("#")]),e._v(" 2.2.3.2 TCP")]),e._v(" "),t("p",[t("strong",[e._v("服务端")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public static void main(String[] args) throws Exception {\n\n    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n    serverSocketChannel.configureBlocking(false);\n    serverSocketChannel.bind(new InetSocketAddress("127.0.0.1",8181));\n\n    while (true){\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        if(socketChannel != null){\n            System.out.println("["+System.nanoTime()+"] 服务器接收到客户端消息:");\n            ByteBuffer readBuffer = ByteBuffer.allocate(10);\n            readBuffer.clear();\n\n            int i = socketChannel.read(readBuffer);\n            while (i != -1){\n                readBuffer.flip();\n                while (readBuffer.hasRemaining()){\n                    System.out.print((char) readBuffer.get());\n                }\n                readBuffer.clear();\n                i = socketChannel.read(readBuffer);\n            }\n        }\n    }\n\n}\n')])])]),t("p",[t("strong",[e._v("客户端")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public static void main(String[] args) throws Exception {\n\n    SocketChannel socketChannel = SocketChannel.open();\n    socketChannel.configureBlocking(false);\n    socketChannel.connect(new InetSocketAddress("127.0.0.1",8181));\n\n    while (socketChannel.finishConnect()){\n        ByteBuffer writeBuffer = ByteBuffer.allocate(1024);\n        writeBuffer.clear();\n        writeBuffer.put(("client request : "+System.nanoTime()).getBytes());\n        writeBuffer.flip();\n        while (writeBuffer.hasRemaining()){\n            socketChannel.write(writeBuffer);\n        }\n    }\n\n}\n')])])]),t("h4",{attrs:{id:"_2-2-3-3-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-3-3-udp"}},[e._v("#")]),e._v(" 2.2.3.3 UDP")]),e._v(" "),t("p",[t("strong",[e._v("发送端")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public static void send() {\n    try {\n        DatagramChannel channel= DatagramChannel.open();\n        int i = 1;\n        while (i<=20){\n            String str = "["+System.nanoTime()+"] udp message";\n            ByteBuffer buffer = ByteBuffer.allocate(50);\n            buffer.clear();\n            buffer.put(str.getBytes());\n            buffer.flip();\n            while (buffer.hasRemaining()){\n                channel.send(buffer,new InetSocketAddress("127.0.0.1",8181));\n            }\n            buffer.clear();\n            System.out.println("---send udp message successfully!");\n            i++;\n        }\n    }catch (Exception e){\n        e.printStackTrace();\n    }\n}\n')])])]),t("p",[t("strong",[e._v("接收端")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public static void receive() {\n    try {\n        DatagramChannel channel= DatagramChannel.open();\n        channel.bind(new InetSocketAddress(8181));\n        int i = 1;\n        while (i<=20){\n            ByteBuffer buffer = ByteBuffer.allocate(50);\n            buffer.clear();\n            channel.receive(buffer);\n            System.out.print("receive udp message :");\n            buffer.flip();\n            while (buffer.hasRemaining()){\n                System.out.print((char) buffer.get());\n            }\n            buffer.clear();\n            System.out.println();\n            i++;\n        }\n    }catch (Exception e){\n        e.printStackTrace();\n    }\n}\n')])])]),t("h3",{attrs:{id:"_2-3-selector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-selector"}},[e._v("#")]),e._v(" 2.3 Selector")]),e._v(" "),t("p",[e._v("Selector 允许一个单一的线程来操作多个 Channel。")]),e._v(" "),t("p",[e._v("如果我们的应用程序中使用了多个 Channel，那么使用 Selector 很方便的实现这样的目的，但是因为在一个线程中使用了多个 Channel，因此也会造成了每个 Channel 传输效率的降低。")]),e._v(" "),t("p",[e._v("使用 Selector 的图解如下:")]),e._v(" "),t("p",[t("img",{attrs:{src:"/img/java/javase/io/1.5.png",alt:"img"}})]),e._v(" "),t("h4",{attrs:{id:"_2-3-1-使用selector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-使用selector"}},[e._v("#")]),e._v(" 2.3.1 使用Selector")]),e._v(" "),t("p",[t("strong",[e._v("创建Selector")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Selector selector = Selector.open();\n")])])]),t("p",[t("strong",[e._v("将Channel注册到Selector")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("channel.register(selector,selectorKey) \n或 \nchannel.register(selector,selectorKey,attObject)\n")])])]),t("p",[e._v("要将channel注册到Selector前必须保证channel是非阻塞的，register方法的第二个参数指定了我们感兴趣的事件，有四种可选值：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("SelectionKey.OP_CONNECT     //channel已连接\nSelectionKey.OP_ACCEPT      //channel确认,用于tcp服务端\nSelectionKey.OP_READ        //channel可读\nSelectionKey.OP_WRITE       //channel可写\n")])])]),t("p",[e._v("如果想要一次性指定多个感兴趣的事件，可以使用”|”运算来组合:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;\n")])])]),t("p",[e._v("注意：一个channel仅可以注册到一个Selector一次，后续注册会覆盖掉之前的注册信息。register方法可以通过第三个参数传入一个附加对象，并且能够在事件发生后获取到该对象。")]),e._v(" "),t("p",[t("strong",[e._v("获取事件")])]),e._v(" "),t("p",[e._v("通过"),t("code",[e._v("selector.selectedKeys()")]),e._v("可以获取所有注册到Selector的所有事件，并可以通过"),t("code",[e._v("isAcceptable()")]),e._v("、"),t("code",[e._v("isConnectable()")]),e._v("、"),t("code",[e._v("isReadable()")]),e._v("、"),t("code",[e._v("isWritable()")]),e._v("来判断事件是否已经准备就绪，并且能够通过"),t("code",[e._v("channel()")]),e._v("方法获取对应的channel，如果存在附加对象，可以通过"),t("code",[e._v("attachment()")]),e._v("方法获取。")]),e._v(" "),t("p",[e._v("注意：在通过"),t("code",[e._v("selectedKeys()")]),e._v("方法获取到事件集合后，如果对该事件进行了处理，那么Selector并不会删除该事件，需要手动删除。")]),e._v(" "),t("p",[e._v("也可以通过"),t("code",[e._v("select()")]),e._v("方法获取准备就绪的事件个数，该方法默认阻塞等待事件就绪。可以通过"),t("code",[e._v("select(long timeout)")]),e._v("方法设置等待时间，也可以通过"),t("code",[e._v("selectNow()")]),e._v("获取，该方法不会阻塞，立刻返回结果。")]),e._v(" "),t("p",[e._v("##@# 2.3.2 示例")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    public static void main(String[] args) throws IOException {\n        Selector selector = Selector.open();\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.bind(new InetSocketAddress("127.0.0.1",8181));\n        //注册事件\n        serverSocketChannel.register(selector,SelectionKey.OP_ACCEPT);\n        while (true){\n            if(selector.selectNow() == 0){\n                //如果没有事件准备就绪,继续下一次循环\n                continue;\n            }\n            Iterator<SelectionKey> selectionKeys = selector.selectedKeys().iterator();\n            while (selectionKeys.hasNext()) {\n                SelectionKey key = selectionKeys.next();\n                if (key.isAcceptable()) {\n                    System.out.println("新的客户端连接成功!");\n                    SocketChannel channel = ((ServerSocketChannel)key.channel()).accept();\n                    channel.configureBlocking(false);\n                    channel.register(key.selector(),SelectionKey.OP_READ,ByteBuffer.allocate(1024));\n                } else if (key.isReadable()) {\n                    System.out.print("读取客户端消息:");\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    buffer.clear();\n                    SocketChannel socketChannel = (SocketChannel) key.channel();\n                    socketChannel.read(buffer);\n                    buffer.flip();\n                    while (buffer.hasRemaining()) {\n                        System.out.print((char) buffer.get());\n                    }\n                    buffer.clear();\n                } \n                selectionKeys.remove();\n            }\n        }\n    }\n')])])])])}),[],!1,null,null,null);t.default=r.exports}}]);