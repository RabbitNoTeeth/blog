(window.webpackJsonp=window.webpackJsonp||[]).push([[97],{383:function(n,t,a){"use strict";a.r(t);var s=a(7),e=Object(s.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("在Java中，static关键字主要有四种用法：")]),n._v(" "),t("ul",[t("li",[n._v("修饰成员变量")]),n._v(" "),t("li",[n._v("修饰成员方法")]),n._v(" "),t("li",[n._v("静态代码块")]),n._v(" "),t("li",[n._v("静态导包")])]),n._v(" "),t("p",[n._v("被static修饰的变量和方法，可以通过类名直接调用，不依赖类的实例；Static代码块在类加载时调用，且只调用一次；使用static导包，类方法可以直接通过方法名调用。")]),n._v(" "),t("p",[n._v("关于static关键字，要掌握类实例化时的加载顺序，同时牢记static变量会被所有类实例共享，并且无法通过gc回收，在多线程设计以及内存优化时要特别注意。")]),n._v(" "),t("p",[n._v("下面进行各个用途的详解")]),n._v(" "),t("h2",{attrs:{id:"_1-修饰成员变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-修饰成员变量"}},[n._v("#")]),n._v(" 1. 修饰成员变量")]),n._v(" "),t("p",[n._v("被static修饰的成员变量属于该类，被所有该类的实例共享，在类初始化时jvm只为static修饰的变量分配一次内存，并且为static变量分配的内存不在java堆内存中，无法通过gc回收，所以对static变量的使用，不仅要考虑多线程带来的问题，同时也要考虑内存占用问题。")]),n._v(" "),t("p",[n._v("下面通过一个小示例来讲解一下static变量与非static变量的区别：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('public class Person {\n\n    public static int age1 = 10;\n\n    public int age2 = 20;\n\n\n    public static void main(String[] args) {\n\n        Person p1 = new Person();\n        Person p2 = new Person();\n\n        System.out.println("--------- 修改前 ---------");\n        System.out.println("p1.age1 = " + p1.age1);\n        System.out.println("p1.age2 = " + p1.age2);\n        System.out.println("p2.age1 = " + p2.age1);\n        System.out.println("p2.age2 = " + p2.age2);\n\n        //更新p1\n        p1.age1 = 15;\n        p2.age2 = 25;\n\n        System.out.println("--------- 修改后 ---------");\n        System.out.println("p1.age1 = " + p1.age1);\n        System.out.println("p1.age2 = " + p1.age2);\n        System.out.println("p2.age1 = " + p2.age1);\n        System.out.println("p2.age2 = " + p2.age2);\n\n    }\n\n}\n输出结果：\n--------- 修改前 ---------\np1.age1 = 10\np1.age2 = 20\np2.age1 = 10\np2.age2 = 20\n--------- 修改后 ---------\np1.age1 = 15\np1.age2 = 20\np2.age1 = 15\np2.age2 = 25\n')])])]),t("p",[n._v("从输出结果中可以看到，对实例p1中age1的修改，影响了p2中age1，而age2由于未被static修饰，在p1和p2之间不存在共享，所以互不影响。")]),n._v(" "),t("h2",{attrs:{id:"_2-修饰成员方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-修饰成员方法"}},[n._v("#")]),n._v(" 2. 修饰成员方法")]),n._v(" "),t("p",[n._v("被static修饰的成员方法可以直接通过类名引用，最熟悉的就是我们常用的各种utils类了，通过定义各种静态方法，方便调用。 但是，被static修饰的方法只能调用static方法和static变量，这是由于static方法在类初次加载就准备好，而普通成员变量或者方法在类被实例化后才准备完毕。 普通方法可以调用static方法和static变量。")]),n._v(" "),t("h2",{attrs:{id:"_3-静态代码块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-静态代码块"}},[n._v("#")]),n._v(" 3. 静态代码块")]),n._v(" "),t("p",[n._v("static代码块会在类初次被加载时调用，并且只调用一次，一般用于执行类共享的初始化动作。一个类中可以存在多个static代码块，并且按照声明的顺序执行。")]),n._v(" "),t("p",[n._v("下面通过两个小示例来深入了解下类加载和实例化的过程：")]),n._v(" "),t("p",[n._v("示例1：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('public class Person {\n\n    public static int age = 10;\n\n    static{\n        System.out.println("age = " + age);\n        System.out.println("static静态代码块1被调用");\n    }\n\n    static{\n        System.out.println("static静态代码块2被调用");\n    }\n\n    public Person(int n){\n        System.out.println("Person"+n+"构造函数被调用");\n    }\n\n\n    public static void main(String[] args) {\n\n        new Person(1);\n        new Person(2);\n\n    }\n\n}\n\n输出结果：\nage = 10\nstatic静态代码块1被调用\nstatic静态代码块2被调用\nPerson1构造函数被调用\nPerson2构造函数被调用\n')])])]),t("p",[n._v("可以看到，static变量和static代码块按照声明的顺序执行且只执行一次，并且都在构造函数进行实例化之前执行。")]),n._v(" "),t("p",[n._v("示例2：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('public class App {\n\n\n    public static void main(String[] args) {\n\n        new Male();\n\n    }\n\n}\n\n\nclass Person {\n\n    Apple apple = new Apple();\n\n    static{\n        System.out.println("父类Person：static静态代码块被执行");\n    }\n\n    public Person(){\n        System.out.println("父类Person：构造函数被调用");\n    }\n\n}\n\nclass Male extends Person{\n\n    static{\n        System.out.println("子类Male：static静态代码块被执行");\n    }\n\n    public Male(){\n        System.out.println("子类Male：构造函数被调用");\n    }\n\n}\n\nclass Apple{\n\n    static{\n        System.out.println("类Apple：static静态代码块被执行");\n    }\n\n    public Apple(){\n        System.out.println("类Apple：构造函数被调用");\n    }\n\n}\n\n输出结果：\n父类Person：static静态代码块被执行\n子类Male：static静态代码块被执行\n类Apple：static静态代码块被执行\n类Apple：构造函数被调用\n父类Person：构造函数被调用\n子类Male：构造函数被调用\n')])])]),t("p",[n._v("通过上述结果，可以得出在实例化一个子类时，执行其父类static代码块 → 执行子类的static代码块 → 初始化父类成员变量 → 初始化子类成员变量 → 调用父类构造函数 → 调用子类的构造函数。")]),n._v(" "),t("h2",{attrs:{id:"_4-静态导包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-静态导包"}},[n._v("#")]),n._v(" 4. 静态导包")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('import static com.dotgua.study.PrintHelper.*;\n\npublic class App{\n    public static void main( String[] args ){\n        print("Hello World!");\n    }\n}\n')])])])])}),[],!1,null,null,null);t.default=e.exports}}]);